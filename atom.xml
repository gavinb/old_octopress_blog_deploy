<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[antonym.org]]></title>
  <link href="http://antonym.org//atom.xml" rel="self"/>
  <link href="http://antonym.org//"/>
  <updated>2014-06-30T23:08:54+10:00</updated>
  <id>http://antonym.org//</id>
  <author>
    <name><![CDATA[Gavin Baker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    
    <title type="html"><![CDATA[C++11 and override]]></title>
    <link href="http://antonym.org//2014/06/c-plus-plus-11-and-override.html"/>
    
    <updated>2014-06-26T18:57:00+10:00</updated>
    <id>http://antonym.org//2014/06/c-plus-plus-11-and-override</id>
    
    <content type="html"><![CDATA[<p>The new <code>override</code> modifier can be applied to a virtual method in C++11, and
instructs the compiler that the method is intended to override a virtual
method defined in the parent class.  The primary advantage is that typos and
mismatched method signatures that would have resulted in subtle bugs and
unintended runtime bheaviour before can now be detected at build time and
easily corrected.</p>

<!--more-->


<h1>Without <code>override</code></h1>

<p>Imagine we have the following code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// Base class with virtual method</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Base0::foo(int)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Derived class with mismatched type.</span>
</span><span class='line'><span class="c1">// This error will not be caught.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived0</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">float</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Derived0::foo(float)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The intent was for <code>Derived0</code> to implement its own <code>foo()</code> method to
override the <code>Base0::foo(int)</code> method.  However, the developer made a
mistake in the type signature and the parameter type does not match (<code>float</code>
here versus <code>int</code> above).  The result is that <code>Derived0::foo(float)</code> is a
distinct method from <code>Base0::foo(int)</code> and will not necessarily be called on
all the occasions the developer intended.  Typically this would be when a
polymorphic call on a <code>Base0</code> pointer type to a <code>Derived0</code> instance was
expected to call the derived implementation.  In other words, given some
test code which exercises the <code>foo</code> method for each class, if we write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base0</span><span class="o">&gt;</span>   <span class="n">b0</span><span class="p">(</span><span class="k">new</span> <span class="n">Base0</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base0</span><span class="o">&gt;</span>   <span class="n">d0</span><span class="p">(</span><span class="k">new</span> <span class="n">Derived0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">b0</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</span><span class='line'><span class="n">d0</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>then the output we see is not what we might expect:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Base0</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span><span class='line'><span class="n">Base0</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The developer had intended that <code>Derived0</code> be invoked in the second call,
but the <code>Base0</code> version was called instead, since it matches the type
signature of the method in the base class and <code>foo(float)</code> is not considered
an overriding method.</p>

<h1>With <code>override</code></h1>

<p>The fix is to add the <code>override</code> modifier to the method declaration in the
derived class to make our intentions explicit.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// Base class with virtual method</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Base1::foo(int)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Derived class intends to override.</span>
</span><span class='line'><span class="c1">// Since parent type signature doesn&#39;t match,</span>
</span><span class='line'><span class="c1">// this error will be caught</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">float</span> <span class="n">num</span><span class="p">)</span> <span class="n">override</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Derived1::foo(int)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now if we attempt to compile this code, we will receive the following error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">override1</span><span class="p">.</span><span class="nl">cpp:</span><span class="mi">28</span><span class="o">:</span><span class="mi">18</span><span class="o">:</span> <span class="nl">error:</span> <span class="err">&#39;</span><span class="n">foo</span><span class="err">&#39;</span> <span class="n">marked</span> <span class="err">&#39;</span><span class="n">override</span><span class="err">&#39;</span> <span class="n">but</span> <span class="n">does</span> <span class="n">not</span> <span class="n">override</span> <span class="n">any</span> <span class="n">member</span> <span class="n">functions</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">float</span> <span class="n">num</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
</span><span class='line'>                 <span class="o">^</span>
</span><span class='line'><span class="mi">1</span> <span class="n">error</span> <span class="n">generated</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>The fix is simple; update the type signature to match the parent.  The code
then compiles, and the following test code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base1</span><span class="o">&gt;</span>   <span class="n">b1</span><span class="p">(</span><span class="k">new</span> <span class="n">Base1</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base1</span><span class="o">&gt;</span>   <span class="n">d1</span><span class="p">(</span><span class="k">new</span> <span class="n">Derived1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">b1</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</span><span class='line'><span class="n">d1</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>works correctly, producing the following expected result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Base1</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span><span class='line'><span class="n">Derived1</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h1>When to use <code>override</code></h1>

<p>The <code>override</code> modifier should be used in modern C++ code whenever a virtual
function is overridden in a derived class.  The use of <code>override</code> can catch
some subtle bugs that would be otherwise be time-consuming and difficult to
detect and correct.</p>

<p>The <code>override</code> modifier only has a compile-time impact, so there is no
runtime cost whatsoever to using it.</p>

<p>There is one consideration &ndash; since <code>override</code> is a C++11 feature, care must
be taken to ensure that the target toolchain is compatible with modern
features.  Older compilers would need a compatability mode to ignore this
modifier in order to build.</p>

<h1>Sample Code</h1>

<p>THe sample code can be otained from:</p>

<ul>
<li><a href="https://github.com/gavinb/cplusplus11/override/">https://github.com/gavinb/cplusplus11/override/</a></li>
</ul>


<h1>Final vs Override</h1>

<p>In addition to the <code>override</code> modifier, there is support for expressing the
opposite sense; the <code>final</code> declaration instructs the compiler that the
method cannot be overridden by a dervied class.  The <code>final</code> modifier is
explained in its own article, <a href="http://antonym.org//2014/06/c-plus-plus-11-and-final.html">C++11 and override</a>.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++11 and final]]></title>
    <link href="http://antonym.org//2014/06/c-plus-plus-11-and-final.html"/>
    
    <updated>2014-06-24T17:50:00+10:00</updated>
    <id>http://antonym.org//2014/06/c-plus-plus-11-and-final</id>
    
    <content type="html"><![CDATA[<p>One of the lesser known &ndash; but still very useful &ndash; enhancements to C++11 is
the addition of the <code>final</code> keyword.  This essentially mirrors the <code>final</code>
feature in Java, which has existed since its inception.</p>

<!--more-->


<p>The <code>final</code> keyword in C++11 can be applied to either an entire class or a
method.  When applied to a class, it signifies that the class is <em>closed to
derivation</em>; that is, you cannot create a class derived from a <code>final</code>
class.</p>

<p>The second way is when applying <code>final</code> to a method, which prevents the
method from being overridden by a derived class (though it is still possible
to create subclasses).</p>

<h1>How do you declare a <code>final</code> class?</h1>

<p>Given a base class and a derived class, you would normally write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived0</span> <span class="o">:</span> <span class="n">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, if you wish to prevent the base class from being subclassed, simply
add <code>final</code> after the classname, thus:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Base1</span> <span class="n">final</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Error!</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="n">Base1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you try to compile this code, you will get the error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">finalclass</span><span class="p">.</span><span class="nl">cpp:</span><span class="mi">16</span><span class="o">:</span><span class="mi">18</span><span class="o">:</span> <span class="nl">error:</span> <span class="n">base</span> <span class="err">&#39;</span><span class="n">Base1</span><span class="err">&#39;</span> <span class="n">is</span> <span class="n">marked</span> <span class="err">&#39;</span><span class="n">final</span><span class="err">&#39;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="n">Base1</span>
</span><span class='line'>                 <span class="o">^</span>
</span><span class='line'><span class="n">finalclass</span><span class="p">.</span><span class="nl">cpp:</span><span class="mi">12</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span> <span class="nl">note:</span> <span class="err">&#39;</span><span class="n">Base1</span><span class="err">&#39;</span> <span class="n">declared</span> <span class="n">here</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Base1</span> <span class="n">final</span>
</span><span class='line'>      <span class="o">^</span>
</span><span class='line'><span class="mi">1</span> <span class="n">error</span> <span class="n">generated</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>The compiler specifically prevents any subclassing of <code>Base1</code> with a hard
error.</p>

<h1>How do you declare a <code>final</code> method?</h1>

<p>It is also possible to mark an indvidual method as <code>final</code>.  The method must
be <code>virtual</code> to begin with, and making it <code>final</code> prevents it from being
overriden in a derived class.</p>

<p>(If the method isn&rsquo;t virtual, you would be effectively creating a shadow
method that overrides the base method.)</p>

<p>Take the following simple example of a derived class overriding a virtual
function declared in the base:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived0</span> <span class="o">:</span> <span class="n">Base0</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>This compiles and works just fine.  But if we wanted to ensure that the
method was not reimplmented in any derived classes (For example, to preserve
important behaviour), simply adding the <code>final</code> modifier at the end of the
method declaration.  So given the following example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Base1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="n">final</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="n">Base1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Error!</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>the compiler gives us the following error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">finalmethod</span><span class="p">.</span><span class="nl">cpp:</span><span class="mi">21</span><span class="o">:</span><span class="mi">10</span><span class="o">:</span> <span class="nl">error:</span> <span class="n">declaration</span> <span class="n">of</span> <span class="err">&#39;</span><span class="n">foo</span><span class="err">&#39;</span> <span class="n">overrides</span> <span class="n">a</span> <span class="err">&#39;</span><span class="n">final</span><span class="err">&#39;</span> <span class="n">function</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>         <span class="o">^</span>
</span><span class='line'><span class="n">finalmethod</span><span class="p">.</span><span class="nl">cpp:</span><span class="mi">16</span><span class="o">:</span><span class="mi">18</span><span class="o">:</span> <span class="nl">note:</span> <span class="n">overridden</span> <span class="k">virtual</span> <span class="n">function</span> <span class="n">is</span> <span class="n">here</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="n">final</span><span class="p">;</span>
</span><span class='line'>                 <span class="o">^</span>
</span><span class='line'><span class="mi">1</span> <span class="n">error</span> <span class="n">generated</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<h1>Why is <code>final</code> useful?</h1>

<p>Marking a method or entire class as <code>final</code> could be useful if you need to
prevent client code from modifying the behaviour of your base class.  This
may be to enforce &lsquo;contractual&rsquo; behaviour (as in Eiffel; not in a legal
sense!), or it may be to prevent resource management problems.</p>

<p>It should be noted that this is in <em>no way</em> a security measure.  This is
purely a compile-time directive to the compiler to enforce the policy, and
has no other effect than to generate an error and stop compiling.  In
attacking any real-world application, a determined cracker would have any
number of mechanisms at their disposal to bypass restrictions that this
might impose.</p>

<p>This information about finality can also be exploited by the compiler to
optimize code, using a technique known as <em>devirtualisation</em>. If the
compiler knows it doesn&rsquo;t have to use the vtable (virtual method table) to
dispatch the method call, it can potentially generate more efficient code.</p>

<h1>Sample Code</h1>

<p>THe sample code can be otained from:</p>

<ul>
<li><a href="https://github.com/gavinb/cplusplus11/final/">https://github.com/gavinb/cplusplus11/final/</a></li>
</ul>


<h1>Final vs Override</h1>

<p>In addition to the <code>final</code> modifier, there is support for expressing the
opposite sense; the <code>override</code> declaration makes it explicit to the compiler
that you are intentionally overriding a virtual method from a base class.
This is explained in its own article, <a href="http://antonym.org//2014/06/c-plus-plus-11-and-override.html">C++11 and
override</a>.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++11 Range-based for loops]]></title>
    <link href="http://antonym.org//2014/02/c-plus-plus-11-range-based-for-loops.html"/>
    
    <updated>2014-02-25T08:44:00+11:00</updated>
    <id>http://antonym.org//2014/02/c-plus-plus-11-range-based-for-loops</id>
    
    <content type="html"><![CDATA[<p>The humble <code>for</code> loop is one of the oldest control flow control constructs
in the Algol family of languages.  Yet while other languages have extended
their syntax to allow <code>for</code> loops to do all sorts of crazy and useful things
beyond iterate over a range of numbers, C and C++ have remained steadfast &ndash;
until now.</p>

<p>The <code>for</code> loop finally has a new syntax to better support iterators and
ranges, just two great new features in C++11.  So you can now easily iterate
over much more than just numbers.</p>

<!--more-->


<p>The C++ container classes in the Standard Template Library (STL) provide
iterators, but the familiar looping syntax is the rather unwieldly pattern:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iter</span> <span class="n">it</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For some time, the <a href="http://www.boost.org/">Boost++ project</a> has provided
some syntactic sugar to reduce the complexity of this code considerably.  By
using the <a href="http://www.boost.org/libs/foreach/">Boost <code>foreach</code></a> library, you
can replace the above loop with the much simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;boost/foreach.hpp&gt;</span>
</span><span class='line'><span class="cp">#define foreach BOOST_FOREACH</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">foreach</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But now the C++11 specification finally has this style of syntax built in to
the language (with a slight change of punctuation; it uses <code>:</code> rather than
<code>,</code>). So now you can write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is obviously much cleaner and clearer than the explicit iterator-based
code shown above.  If all you need to do is iterate over an STL container,
you can start using this syntax straight away.</p>

<p>(Aside: if you are actually going to sum the contents of a vector as in this
example, using the <code>reduce</code> algorithm is even better.)</p>

<h2>The new <code>for</code> loop in detail</h2>

<p>So how does this new <a href="http://en.cppreference.com/w/cpp/language/range-for">range-based <code>for</code></a>
loop actually work?  Well, given the simple expression:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="n">range_declaration</span> <span class="o">:</span> <span class="n">range_expression</span> <span class="p">)</span> <span class="n">loop_statement</span>      
</span></code></pre></td></tr></table></div></figure>


<p>this loop is equivalent to the following expanded code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="o">&amp;&amp;</span> <span class="n">__range</span> <span class="o">=</span> <span class="n">range_expression</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">__begin</span> <span class="o">=</span> <span class="n">__range</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">__end</span> <span class="o">=</span> <span class="n">__range</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span><span class='line'>        <span class="n">__begin</span> <span class="o">!=</span> <span class="n">__end</span><span class="p">;</span> <span class="o">++</span><span class="n">__begin</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">range_declaration</span> <span class="o">=</span> <span class="o">*</span><span class="n">__begin</span><span class="p">;</span>
</span><span class='line'>        <span class="n">loop_statement</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Stepping through line by line, we see that the <code>for</code> loop lives inside its
own block. First, <code>__range</code> is evaluated to determine the sequence over
which to iterate.  Then (as in the traditional container case) the <code>_begin</code>
and <code>__end</code> variables are used to control the loop, incrementing <code>__begin</code>
until it reaches <code>__end</code> (which is one past the last entry).  The loop body
dereferences the iterator to get the item value at the current position, and
then the code in <code>loop_statement</code> is executed.</p>

<p>This construct also works naturally with plain arrays, where the bound is
added to the beginning to determine the range.</p>

<p>Finally, this works with the new <code>begin()/end()</code> range functions in the
C++11 standard library, described next.</p>

<h2>Ranges</h2>

<p>Iterators defined by containers in the STL have <code>begin()</code> and <code>end()</code>
methods to control iteration loops.  New in C++11 are <code>begin()</code> and <code>end()</code>
<em>functions</em> (in the <code>std</code> namespace), which can be used to work with ranges.
So what is a range?  Essentially a <code>begin()/end()</code> pair which define the
extents of an iteration over a container.  By making <code>begin()/end()</code> common
functions, generic algorithms can more easily work with user-defined
containers that live outside the STL.</p>

<p>The simple form of their declarations are as follows:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">C</span> <span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">begin</span><span class="p">(</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">C</span> <span class="o">&gt;</span>
</span><span class='line'><span class="k">auto</span> <span class="n">end</span><span class="p">(</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>This uses some new C++11 features to basically say that, for whatever type
you pass to these functions, they will return you something of the same type
as the <code>begin()</code> or <code>end()</code> methods they define within the class.  This
works with C style arrays, initialiser lists, STL containers and any
user-defined types.  In short, it is a much more flexible form of the
original STL pattern.</p>

<h2>Custom classes and ranges</h2>

<p>To add range support to your own class, you must provide the following support:</p>

<ul>
<li><code>begin()</code> and <code>end()</code>, either as methods or overloaded functions, that
return the appropriate iterators</li>
</ul>


<p>and then you need an iterator class with the following features:</p>

<ul>
<li>dereferencing to access the current item (<code>operator*</code>)</li>
<li>inequality to compare iterators (<code>operator!=</code>)</li>
<li>pre-increment to advance the iterator to the next item (<code>operator++</code>)</li>
</ul>


<p>Given a container class, you could define your iterator class something like
this, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">MyIterator</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">MyContainer</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="o">:</span> <span class="n">m_container</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
</span><span class='line'>              <span class="n">m_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Required</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyIterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">m_index</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_index</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Required</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">MyIterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">m_index</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Required</span>
</span><span class='line'>    <span class="n">MyObject</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">MyContainer</span><span class="o">&amp;</span>      <span class="n">m_container</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span>                <span class="n">m_index</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">MyObject</span><span class="o">&amp;</span> <span class="n">MyIterator</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">m_container</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">m_index</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Its responsibilities are primarily to keep a reference to its container
proper, and maintain the index of the current item.  The methods marked
<code>required</code> are the minimum interface to participate in the range-based <code>for</code>
loop support.  The implementation is very straightforward.</p>

<p>The container class must provide methods to generate iterator classes;
something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">MyContainer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">MyContainer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">capacity</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Required</span>
</span><span class='line'>    <span class="n">MyIterator</span> <span class="n">begin</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">MyIterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Required</span>
</span><span class='line'>    <span class="n">MyIterator</span> <span class="n">end</span> <span class="p">()</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">MyIterator</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">m_currentIndex</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>This allows your own custom classes to be used in a very natural way with
the new <code>for</code> loop, such as this example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">MyContainer</span>     <span class="n">cont</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">cont</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyObject</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s">&quot;IX&quot;</span><span class="p">));</span>
</span><span class='line'><span class="n">cont</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyObject</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="s">&quot;LVI&quot;</span><span class="p">));</span>
</span><span class='line'><span class="n">cont</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyObject</span><span class="p">(</span><span class="mi">43</span><span class="p">,</span> <span class="s">&quot;XLIII&quot;</span><span class="p">));</span>
</span><span class='line'><span class="n">cont</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyObject</span><span class="p">(</span><span class="mi">1984</span><span class="p">,</span> <span class="s">&quot;MCMXXCIV&quot;</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">cont</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">number</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">description</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The full source to the examples is available in my <a href="https://github.com/gavinb/cplusplus11/rangefor/">Github C++11 samples</a>.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++11 Futures]]></title>
    <link href="http://antonym.org//2014/02/c-plus-plus-11-futures.html"/>
    
    <updated>2014-02-25T08:44:00+11:00</updated>
    <id>http://antonym.org//2014/02/c-plus-plus-11-futures</id>
    
    <content type="html"><![CDATA[<p>Concurrency is one of the most significant challenges facing software
development today.  As the gains in processor performance diminish year over
year, additional cores have become the norm.  For some years now, multicore
processors have become the norm.</p>

<p>Taking advantage of multiple cores has usually required writing multithreaded
code, which can be complex to design and debug.  One of my favourite new
features in the C++11 standard library is the <code>future</code> module.  This provides
an extra layer of abstraction over threads, providing a simple mechanism
for asynchronous (ie. concurrent) processing.</p>

<!-- more -->


<h2>What is a &lsquo;future&rsquo;?</h2>

<p>A <code>std::future</code> is an object that represents the future return value of a
function; it is the result of a computation which you need but do not yet have.
A <code>std::future</code> object also represents the current processing state of this
computation; whether or not it has completed, for example.</p>

<p>An asynchronous task (which is generally created on its own thread) makes a
<em>promise</em> that it will process a result at some time in the <em>future</em> and
eventually return this result to the caller.</p>

<h2>When are futures useful?</h2>

<p>If your application needs to perform a non-trivial computation which could take
quite some time to complete, it is frequently preferrable to perform this
computation asynchronously; that is, in another thread, so the calling or main
function can continue processing, perform other tasks, remain responsive to the
user, and so on.</p>

<p>Futures can also be very useful when there are multiple computations to perform,
and it is not known which will complete first.  They can all be initiated at the
same time, and the results picked up as each finishes.</p>

<h2>How do I perform an async call?</h2>

<p>Imagine we have a boring function which will take an undetermined but long time
to complete:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">unsigned</span> <span class="n">boring</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Consume many CPU cycles...</span>
</span><span class='line'>    <span class="c1">// ...then eventually...</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">boring_result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rather than calling this function directly and waiting for its result, we can
invoke it asynchronously:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">boring</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is returned <em>immediately</em> is a <code>future</code> object or token (templated over the
return type of the function we are calling), which allows us to query the status
of the computation, and (once complete) retrieve the result of the <code>boring()</code>
function.</p>

<p>Processing in the calling thread (in this case, <code>main</code>) continues, as the
<code>boring</code> function is spun off into its own thread (an implementation detail) to
be scheduled independently.  In this way, we can continue to perform other
processing while this boring work is being done in the background.</p>

<p>To retrieve the answer, we simply call <code>get()</code> on the <code>future</code> object when we
need to access the result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">unsigned</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will block until the result of the <code>future</code> is ready, and then return
the value from <code>boring()</code>.</p>

<p>To avoid blocking on the result, you can use the <code>wait_for()</code> or <code>wait_until()</code>
methods to check on the status of the <code>future</code>.</p>

<h2>How do I monitor the future&rsquo;s status?</h2>

<p>While the calling process is performing other work, it might be useful to check
if the asynchronous processing has completed yet.  We can either wait for
a certain time to elapse (<code>wait_for()</code>) or wait until a clock time is reached
(<code>wait_until()</code>).  This fragment shows how you can wait 5ms for a result,
retrieving it if available, and continuing if not:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">wait_time_ms</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">future_status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">wait_time_ms</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>A more complete example shows monitoring the status of multiple <code>async</code> calls,
displaying the result as each finishes.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++11 Smart Pointers: Shared Pointer]]></title>
    <link href="http://antonym.org//2014/02/c-plus-plus-11-shared-pointer.html"/>
    
    <updated>2014-02-13T18:45:00+11:00</updated>
    <id>http://antonym.org//2014/02/c-plus-plus-11-shared-pointer</id>
    
    <content type="html"><![CDATA[<p>In the last article on smart pointers, we looked at <code>std::unique_ptr</code>, which
provides a simple and safe smart pointer to wrap heap allocations.  As the name
implies, this smart pointer type cannot be shared between multiple threads.</p>

<p>So then how can you ensure that the memory is freed once all referring threads
have finished with the resource?  This is especially difficult when the thread
lifecycle is non-deterministic.</p>

<!--more-->


<p>The solution to sharing heap-allocated memory between threads is the
<code>std::shared_ptr</code>. While it does <strong>not</strong> address race conditions (see mutexes et
al), it does solve the problem of managing the lifecycle of a shared resource
between multiple threads.</p>

<h2>Reference Counting</h2>

<p>The <code>shared_ptr</code> implementation uses reference counting to keep track of how
many references to the object exist. Each time the smart pointer is replicated,
the reference count is increased. Each time a smart pointer goes out of scope,
the reference count is decreased. Once the final reference is gone (ie. the
reference count reaches zero), the object is deleted (and the destructor
called).</p>

<h2>Example</h2>

<p>Imagine we have a worker thread function which needs to use a shared resource.
We can pass the worker thread a shared pointer:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">worker</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;tid %p worker: running, obj %p use_count %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">obj</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">obj</span><span class="p">.</span><span class="n">use_count</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Do something useful with obj</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can use the object in as many threads as we need, and they can all terminate
at an arbitrary time. The object will stay alive until the last thread has
finished, and releases its reference.</p>

<p>In this example, the <code>main()</code> function creates an instance, then passes the
smart pointer to several worker threads:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">w1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">obj</span><span class="p">));</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">w2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">obj</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="n">w1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="n">w2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note the use of <code>std::bind</code> to pass the <code>obj</code> pointer as a reference parameter
to the thread function;  normally thread function parameters are passed by
value.</p>

<p>The output will resemble something like:</p>

<pre><code>+++ main()
+++ Foo::Foo()
main:   spawning, obj use_count 1
main:   joining,  obj use_count 3
worker: running,  obj use_count 3
worker: running,  obj use_count 2
main:   leaving,  obj use_count 1
--- main()
--- Foo::~Foo()
</code></pre>

<p>We clearly see the lifecycle of the <code>Foo</code> instance.  In <code>main</code>, it is created
and thus the <code>use_count</code> is 1 (before the threads are spawned).  Then two
threads are spawned, increasing the <code>use_count</code> to 3, which remains while the
threads are running. Main joins (or waits) to block on each thread terminating,
so once <code>main</code> continues, both threads have completed, thus the <code>use_count</code> is
back down to 1. Finally, the smart pointer goes out of scope at the end of main,
and is destroyed after main completes.</p>

<p>The new <code>std::shared_ptr</code> support makes it easy to share heap-allocated memory
between threads, or throughout code that has complex lifetime requirements.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[C++11 Smart Pointers: Unique Pointer]]></title>
    <link href="http://antonym.org//2014/01/c-plus-plus-11-unique-pointer.html"/>
    
    <updated>2014-01-31T18:29:00+11:00</updated>
    <id>http://antonym.org//2014/01/c-plus-plus-11-unique-pointer</id>
    
    <content type="html"><![CDATA[<p>C++11 introduces many significant improvements to the language and runtime. One
of the most important is to do with memory management &ndash; specifically, smart
pointers.  The <code>unique_ptr</code> makes managing dynamically allocated memory safe and
simple.</p>

<!--more-->


<p>Instead of using a bare pointer type in C++, the modern C++11 style is now to
use <code>std::unique_ptr</code>.  This class will automatically free the allocated memory
once the variable goes out of scope.  This is the simplest of the new smart
pointer types in C++11.</p>

<p>Whereas before, you might write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Foo</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">obj</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>you can now write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">obj</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// obj will be automatically deleted</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Properties</h2>

<p>The <code>std::unique_ptr</code> class enforces several useful properties:</p>

<ul>
<li>only a single reference to the allocated object can be active at any given time</li>
<li>the object will be deleted when the smart pointer goes out of scope</li>
<li>the object will be deleted if an exception is thrown</li>
</ul>


<p>It bears spelling this out: when used correctly, <code>std::unique_ptr</code> can virtually
eliminate memory leaks.  This makes the cost of the conversion process
worthwhile!</p>

<p>The <code>unique_ptr</code> type is templated over the pointer type, and its constructor
takes the allocated pointer returned from the <code>new</code> operator.  And because the
pointer <code>operator-&gt;()</code> is overloaded, the smart pointer object can be used just
like a regular pointer.</p>

<p><strong>Note 1:</strong> For Boost users, this is almost the same as the <code>boost::scoped_ptr</code>
class.</p>

<p><strong>Note 2:</strong> This class supercedes the <code>std::auto_ptr</code>, which was deprecated in C++11.</p>

<p><strong>Note 3:</strong> When invoking <code>std::unique_ptr</code> methods on the smart pointer itself,
remember to use the dot <code>.</code> operator. When invoking methods on the object pointer,
use the arrow <code>-&gt;</code> operator as you normally would (since it is overloaded to return the underlying object pointer).</p>

<h2>Sample</h2>

<p>Once the variable goes out of scope, <code>delete</code> will be called to release the memory,
and the destructor will be invoked as usual, as this simple example shows:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;memory&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;+++ Foo::Foo()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;--- Foo::~Foo()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">process</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;... Foo::process()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;+++ main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;--- main()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The output is:</p>

<pre><code>+++ main()
+++ Foo::Foo()
... Foo::process()
--- main()
--- Foo::~Foo()
</code></pre>

<h2>Explcit release</h2>

<p>If you wish to delete the object before the holding pointer goes out of scope,
you can use the <code>reset()</code> method on the smart pointer:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">obj</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'><span class="n">obj</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Notice that methods invoked on the smart pointer itself use <code>.</code> whereas
methods on the target object use the overloaded dereference operator <code>-&gt;</code>).</p>

<p>This results in the trace:</p>

<pre><code>+++ main()
+++ Foo::Foo()
... Foo::process()
... obj: 0x7fb733c047c0
--- Foo::~Foo()
--- main()
</code></pre>

<p>The simple difference here is that the object&rsquo;s destructor is called <em>before</em>
the end of <code>main</code>, since we invoke <code>reset()</code> explicitly.  Above, the destructor
is invoked <em>after</em> the end of <code>main</code>, since the smart pointer is going out of
scope.  This is a subtle but important point.</p>

<h2>Uniqueness</h2>

<p>What happens if we try to assign this pointer to another smart pointer?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">obj2</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We get a meaningful compiler error:</p>

<pre><code>cpp11_unique_ptr_ex2.cpp:27:10: error: object of type 'std::__1::unique_ptr&lt;Foo,
      std::__1::default_delete&lt;Foo&gt; &gt;' cannot be assigned because its copy
      assignment operator is implicitly deleted
    obj2 = obj;
</code></pre>

<p>The compiler is enforcing the unique ownership semantics, so we can&rsquo;t
accidentally do the wrong thing.</p>

<p>But if we can&rsquo;t assign these unique pointers, how do we move them around? Using
the new explicit <em>move</em> support in C++11 (which is itself a large and complex
topic). This transfers ownership of the pointer from one <code>unique_ptr</code> instance
to another:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj1</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">obj2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The output of the test program shows the result (we can access the enclosed pointer
using the <code>get()</code> method):</p>

<pre><code>+++ main()
+++ Foo::Foo()
Before move:
     obj1:0x7fa8b9d00000
     obj2:0x0
After move:
     obj1:0x0
     obj2:0x7fa8b9d00000
--- main()
--- Foo::~Foo()
</code></pre>

<p>Notice how only one <code>Foo</code> instance was created, and that its pointer value moved
from <code>obj1</code> to <code>obj2</code>? After the <code>move</code> operation, the pointer in <code>obj1</code> is null.
Thus move semantics preserve the single owner invariant.</p>

<h2>Arrays</h2>

<p>The <code>std::unique_ptr</code> class also has explicit support for handling arrays of
pointers. It is not a replacement for <code>std::vector</code>, but depending on your
requirements, this array support can be very useful.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">objarray</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span> <span class="p">[</span><span class="n">N</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">objarray</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Returning objects from functions</h2>

<p>The <code>unique_ptr</code> idiom is especially useful when you need to return an allocated
resource from a function or method, but don&rsquo;t want to worry about having to free
the object later.  This sample function returns a unique pointer to the caller,
transferring ownership by implicitly moving the result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">make_foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// prepare obj</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The object will be freed when the caller stops referencing it.</p>

<h2>Containers</h2>

<p>The <em>move</em> support enables efficient storage of <code>unique_ptr</code> managed objects in
containers (one of the limitations of the deprecated <code>std::auto_ptr</code>).  If you
have a vector of pointers to objects, you need to carefully manage ownership
(eg. does the creator or the container own the allocations?) and manually free
them. But with <code>unique_ptr</code>, instead of:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>we can write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>then when creating the object, we use the explicit <em>move</em> support to pass
ownership of the object to the container (and avoid any reallocations or
temporaries):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>When the <code>vector</code> goes out of scope, its destructor will in turn release all
the <code>unique_ptr</code> instances it owns.  This automatic releasing of resources
can save a great deal of debugging pain and potential memory leaks.</p>

<h2>Overhead</h2>

<p>The benefits of using <code>std::unique_ptr</code> are many.  And fortunately, the cost of
using this support is minimal (though for embedded systems, needs to be
carefully considered).  The is a memory overhead of one word per instance (eg. 8
bytes on a 64-bit architecture).</p>

<p>The code generated for a method invocation involves an extra pointer
indirection, the overhead which seems to be in the order of 2-3% (based on some
simplistic tests; see the repo for full source).</p>

<h2>Upgrading</h2>

<p>The process to convert existing code which uses manual memory management to
using smart pointers may not be trivial, but the long-term benefits of more
maintainable and reliable code are frequently worth the investment of time.
Going through the process may well highlight complex memory management
strategies or error-prone code, and eliminate even more problems.</p>

<ul>
<li>Search for allocations using <code>new</code></li>
<li>Remove calls to <code>delete</code></li>
</ul>


<h2>Other smart pointer types</h2>

<p>Stay tuned for articles on:</p>

<ul>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Modern C++11 Memory Management]]></title>
    <link href="http://antonym.org//2014/01/modern-c-plus-plus-11-memory-management.html"/>
    
    <updated>2014-01-31T09:41:00+11:00</updated>
    <id>http://antonym.org//2014/01/modern-c-plus-plus-11-memory-management</id>
    
    <content type="html"><![CDATA[<p>Memory management in low level code has changed slowly over the years.  In
traditional C code, you would allocate memory with <code>malloc()</code> and release it
with <code>free()</code>.</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char* buffer = malloc(BUFFER_SIZE);
</span><span class='line'>
</span><span class='line'>fill_buffer(buffer, BUFFER_SIZE);
</span><span class='line'>process_buffer(buffer, BUFFER_SIZE);
</span><span class='line'>
</span><span class='line'>free(buffer);</span></code></pre></td></tr></table></div></figure>


<p>Some of the problems with this approach were:</p>

<ul>
<li><code>malloc()</code> might fail if the system is running low on memory, so you would
have to check for a <code>NULL</code> return and handle the error appropriately.</li>
<li>you might forget to call <code>free()</code>, thus leaking memory. This is especially
common when there are multiple code paths, early returns and so on.</li>
<li>the memory might be referred to <em>after</em> its release, causing subtle bugs
or crashes.</li>
<li>sharing the memory between threads was error-prone and relied on complex
systems to avoid leaking or trashing memory.</li>
</ul>


<p>The above code is also perfectly valid C++, albeit not exactly idiomatic.
Rather than rely on the C runtime, C++ introduced heap management into the
language itself, with the <code>new</code> and <code>delete</code> operators:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Buffer</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Buffer</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">);</span>
</span><span class='line'><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">delete</span> <span class="n">buffer</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This too is not without its issues:</p>

<ul>
<li>If the system is low on memory, <code>new</code> could fail and throw an exception
(the default behaviour). This would require a <code>try/catch</code> block to handle
the failure, otherwise the program would abort.</li>
<li><code>new</code> could also be configured to return <code>NULL</code>, requiring an entirely
different error handling strategy.</li>
<li>It is generally inadvisable to mix memory allocated with <code>new</code> with memory
allocated using <code>malloc()</code> (as they could potentially be allocated in
different heap areanas, and cause corruption).</li>
</ul>


<h2>Modern Memory Management</h2>

<p>To drastically simplify memory management and reduce the potential for bugs,
C++11 introduces several types of <em>smart pointers</em>:</p>

<ul>
<li><code>std::unique_ptr</code>: a pointer which is automatically freed when the pointer
goes out of scope, and has a single owner at all times</li>
<li><code>std::shared_ptr</code>: a reference-counting pointer which can be shared among
multiple threads, and deletes the object when the last reference is released</li>
<li><code>std::weak_ptr</code>: a handle which does not hold a reference, but can be
materialised into a <code>std::shared_ptr</code> on demand</li>
</ul>


<p>These three smart pointer types should be able to cover the vast majority of
memory management needs in a typcail application.  (There will always be
exceptions which need custom allocation strategies, such as high performance
games, numerical processing, etc).</p>

<p>By using the correct smart pointer according to the desired semantics, you
can virtually eliminate leaks and other common memory problems.</p>

<p>These are each covered in detail in their own articles below:</p>

<ul>
<li><a href="http://antonym.org//2014/01/c-plus-plus-11-unique-pointer.html">Unique Pointer</a></li>
<li><a href="http://antonym.org//2014/02/c-plus-plus-11-shared-pointer.html">Shared Pointer</a></li>
<li>Weak Pointer (TBA)</li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[What is Rust?]]></title>
    <link href="http://antonym.org//2013/10/what-is-rust.html"/>
    
    <updated>2013-10-08T20:50:00+11:00</updated>
    <id>http://antonym.org//2013/10/what-is-rust</id>
    
    <content type="html"><![CDATA[<p><a href="http://www.rust-lang.org/">Rust</a> is a compiled, hybrid imperative/object-
oriented/functional language. It appeals directly to any C++ developer who has
battled with memory management, and Python developers who long for faster code.
So why might you be interested in learning Rust?</p>

<!--more-->


<p>It&rsquo;s <strong>compiled</strong>, so it&rsquo;s fast. Rust uses <a href="http://www.llvm.org/">LLVM</a> as the
compilation engine, and benefits from all its optimisation and native code
generation support that targets ARM and Intel processors.</p>

<p>Rust uses <strong>type inference</strong>, so you can write cleaner, simpler code while
retaining the benefits of strong static typing. It also supports <strong>generic</strong> and
<strong>algebraic types</strong>, which offers a far richer type system than C++.</p>

<p>There are no <code>NULL</code> pointers, thus rendering an entire class of bugs impossible.
This alone is worth a serious look, as the security and reliability implications
are huge.</p>

<p>Rust is a brace-oriented like C/C++, so many aspects of the syntax will be
immediately familiar to existing developers.</p>

<p>Memory ownership semantics are rich, strict and enforced. There are owned
pointers, shared pointers and <em>optional</em> garbage-collection.</p>

<p>Rust has first-class <strong>concurrency</strong> support, featuring lightweight tasks
and message passing.</p>

<p>What does it look like? I would describe it as terse &ndash; or rather, minimalist.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello, world&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ok, that&rsquo;s not very useful. How about a naïve Fibonacci function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span> <span class="k">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">uint</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">match</span> <span class="n">n</span> <span class="p">{</span>
</span><span class='line'>        <span class="m">0.</span><span class="p">.</span><span class="m">1</span>    <span class="o">=&gt;</span> <span class="m">1</span><span class="p">,</span>
</span><span class='line'>        <span class="n">_</span>       <span class="o">=&gt;</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes, Rust has <strong>pattern matching</strong> just like Haskell. Forget about the simple
<code>switch</code> statement &ndash; <code>match</code> is super-powerful and flexible, supporting ranges,
options and destructuring fields from <code>struct</code>s.</p>

<p>What about some tasks:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">test_tasks</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;About to spawn...&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello from the first subtask!&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="n">spawn</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello from another subtask!&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Despite having spent years working in C++, I have often lamented its
shortcomings. Yet until recently, no other language seems to have come close to
competing with C++ as a systems language.</p>

<p>The <a href="http://dlang.org">D programming language</a> looks very interesting, and aims
to provide a worthy alternative to C++.  However, last time I looked, there was
a schism over the runtime libraries which made adoption difficult. Uncertainty
about such a fundamental aspect is not reassuring for potential users.</p>

<p>The <a href="http://www.go-lang.org/">Go programming language</a> from Google is fantastic,
and I have already used it on a number of small projects. The only shortcoming I
see here is the garbage collection, which makes real-time systems impractical.</p>

<p>Rust has great promise, and also has both Mozilla and Samsung backing its
progress. There is a vibrant, friendly and smart community behind it, and a
growing number of third-party libraries are supported. I am very optimistic
about the future of Rust, and look forward to contributing.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threading with Boost - Part IV: Mutex Examples]]></title>
    <link href="http://antonym.org//2012/02/threading-with-boost---part-iv-mutex-examples.html"/>
    
    <updated>2012-02-22T00:00:00+11:00</updated>
    <id>http://antonym.org//2012/02/threading-with-boost&#8212;part-iv-mutex-examples</id>
    
    <content type="html"><![CDATA[<p>This article continues the series on threading with Boost, by looking in
depth at several sample programs which illustrate different aspects of
mutexes.  We look at the code, and discuss how it is implemented, including
how to avoid common problems.</p>

<!--more-->


<h1>Mutex Examples</h1>

<p>The full source for the sample applications is provided below.  It is
designed to be fully portable, and has been tested on Mac OS X and Linux.
It should work fine on Windows (please send a patch if it doesn&rsquo;t!).</p>

<p>You can browse all the sources in the <a href="http://bitbucket.org/gavinb/boost_samples">Boost Samples repository</a>
for the latest, or use <a href="http://www.selenic.com/mercurial/">Mercurial</a>
to clone your own copy with this shell command:</p>

<pre><code>hg clone http://hg.antonym.org/src/boost_mutex
</code></pre>

<p>Running <code>bjam</code> or <code>make</code> will build all the examples for you, which you can
run from the appropriate subdirectory (depending on your toolchain and
architecture).</p>

<h1>Duelling Threads</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/duel.cpp"><code>duel.cpp</code></a></p>

<p>This example shows how threads are sensitive to timing and scheduling.
There is a global counter which starts at 0.  Two threads are created which
both try to modify the same counter; one incrementing and the other
decrementing.  The program runs for a fixed time, then the counter is
printed.</p>

<p>What would you expect to happen?  (It is worth thinking about this before
reading on&hellip;!)  Assuming the threads get equal time to run, you would think
that their effects would cancel each other out &ndash; that the same number of
increments and decrements would occur, and the result would be 0, or at
least very close to 0. Right?</p>

<p>Here&rsquo;s the result of running the test 10 times for 5 seconds each:</p>

<pre><code>Final counter = -1
Final counter = -3
Final counter = 1
Final counter = -1
Final counter = 0
Final counter = 3
Final counter = -57
Final counter = -8
Final counter = 7
Final counter = -5
</code></pre>

<p>Often the result is quite close to zero, but there are several runs which
are significantly above or below 0. And there&rsquo;s one huge outlier where one
of the counter threads (quiz: which one?) was starved of some time while the
other kept working (answer: the incrementing thread, since the counter is
negative, indicating that the decrementing thread was scheduled for longer).</p>

<p>So even on a machine with very few other processes running, even small
variations in timing and scheduling can lead to a significant variation in
the result.</p>

<p>The moral of this story: <em>the interaction between threads is time-sensitive
and non-deterministic</em> (in the absence of synchronisation).</p>

<h1>Trylock with Queueing Threads</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/trylock.cpp"><code>trylock.cpp</code></a></p>

<p>This sample illustrates two cooperating threads: a <em>producer</em> which places
work items in a queue, and a <em>consumer</em> which removes work items from the
queue.  The shared queue is protected by a mutex.</p>

<p>Each thread locks the mutex when pushing or pulling work items, to protect
against concurrent access.  Work items are arbitrarily represented by random
numbers.  Each thread holds the lock for a random time delay to simulate
processing.</p>

<p>Since the producer may be holding the lock when the consumer wants to access
the queue (or vice versa), the consumer performs a <code>try_lock</code> on the mutex.
So instead of blocking until the mutex is free (as a regular call to
<code>lock()</code> would), the call fails immediately if the mutex is already locked,
and the thread resumes.  This contention is reported separately, as it is
important to be able to see how often the threads collide.</p>

<p>Each thread prints out the stage it is executing, to enable analysis of the
interaction.</p>

<p>Note that this technique is <strong>not</strong> a good model for real world use &ndash; it is
specifically designed to illustrate one aspect of using mutexes.  For a much
better implementation of the Producer-Consumer pattern, see the article on
Boost Condition variables later in this series.</p>

<p>Takehome message: <em>thread contention for shared resources wastes processor
cycles and can erase performance improvements gained from concurrent code</em>.</p>

<h1>Mutex Locking with Timeout</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/timedlock.cpp"><code>timedlock.cpp</code></a></p>

<p>Shows how to use <code>try_lock</code> on a mutex.  A &lsquo;holding&rsquo; thread idles for a
short time, then grabs the mutex and holds it for another short time before
unlocking it.  The second thread is the &lsquo;trying&rsquo; thread, in that it idles
and then <em>tries</em> to acquire a lock on the mutex.  But it specifies a timeout
by calling the <code>timed_lock()</code> method, and can fail if the holding thread
hasn&rsquo;t released the mutex in time.  If it manages to grab the mutex, it
holds it for a short time also.  The idle and holding times are different,
to ensure the threads don&rsquo;t run in lockstep.  Note that <code>unlock()</code> is only
called if the lock succeeds!</p>

<p>Recommended Usage: <em>Use a timeout when trying to lock a mutex if you can
easily do some other useful work, or if you cannot guarantee you can acquire
the resource within a reasonable timeframe.</em></p>

<h1>Recursive Lock</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/reclock.cpp"><code>reclock.cpp</code></a></p>

<p>Illustrates recursively locking a mutex.  A singleton class,
ResourceManager, can register and unregister clients.  Since this may be
called from the context of any worker thread, it uses a mutex when accessing
the dictionary of client information.  Since retain/release management also
requires the mutex be held during updates, this serves as an illustration of
recursive locking.  These methods can be called individually, or from within
the register/unregister methods, which also hold the mutex.  For example:</p>

<pre><code>registerClient()                  lockCount = 0
    mMutex.lock()                 lockCount = 1
    retainClient()                lockCount = 1
        mMutex.lock()             lockCount = 2
        mMutex.unlock()           lockCount = 1
    mMutex.unlock()               lockCount = 0
</code></pre>

<p>Npte: <em>Recursive mutexes should be used rarely, if at all. Thinking you Need
a recursive mutex may be a sign that you have a structural problem with the code.</em></p>

<p>Fun fact: <em>The person who implemented recursive mutexes in <code>pthreads</code> did it
as a bit of a joke, just to prove it was possible &ndash; not really intending for
them to be used in real programs.</em></p>

<h1>Deadlock</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/deadlock.cpp"><code>deadlock.cpp</code></a></p>

<p>Imagine you have multiple co-operating threads as well as multiple shared
resources.  Each shared resource is dutifully protected by its own mutex.
So provided each thread locks the mutex before accessing the resource,
everything should run smoothly, right? What could possibly go wrong?</p>

<p>A <a href="http://en.wikipedia.org/wiki/Deadlock"><strong>deadlock</strong></a> is what could go
wrong, and appears as if the program has simply hung.  It&rsquo;s relatively easy
for these situations to occur, but it is also relatively easy to prevent
deadlocks with some care and thought.</p>

<p>A deadlock occurs when thread one is holding lock A while waiting for lock
B, which itself is held by thread two which is waiting for lock A.  In other
words, the two threads are both waiting for each other to do something that
can never happen.  An <em>impasse</em>!</p>

<p>Now this example is <em>intentionally</em> written to fall into a deadlock.  So
whatever you do, don&rsquo;t copy the code from this example into your own code.
Study it and make sure you understand <em>why</em> it is wrong.</p>

<p>In the source, thread one wants to lock both mutex A and mutex B, and it
does so in that order.  It will then perform some processing, and unlock the
two mutexes.  Thread two is similar, in that it wants to lock mutex A and
mutex B before it can safely do its work.  However, the poor programmer who
wrote this code hadn&rsquo;t had their second cup of coffee that morning, and
wrote the code such that it first locks mutex B, <em>then</em> mutex A.  No big
deal, right?</p>

<p>The program prints information about its progress, including which thread is
in what state, such as processing, waiting for a lock, and so on.  This
makes it easier for us to analyse what is going on.  (When debugging
multithreaded code, <code>printf</code> is your friend!)</p>

<p>Each thread holds both locks while they work, which can take a random length
of time.  This setup can work ok for a little while, provided the timing is
just right.  This can be seen in the trace below, which shows the normal
output of the program:</p>

<pre><code>ONE idle
TWO idle
ONE wait_A
ONE wait_B
ONE processing
TWO wait_B
ONE unlock_B
ONE unlock_A
ONE idle
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
TWO wait_B
TWO wait_A
TWO processing
ONE wait_A
TWO unlock_A
TWO unlock_B
TWO idle
ONE wait_B
ONE processing
ONE unlock_B
ONE unlock_A
ONE idle
TWO wait_B
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
TWO wait_B
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
...
</code></pre>

<p>but before long at all, the program will invariably hang.  At this point,
you will have to use <code>Control-C</code> (or your platform&rsquo;s equivalent) to kill the
program.  And if you run it a few times, you will notice the same two
patterns always appearing at the end of the trace; either:</p>

<pre><code>...
ONE wait_A
TWO wait_B
ONE wait_B
TWO wait_A
</code></pre>

<p>or:</p>

<pre><code>...
TWO wait_B
ONE wait_A
TWO wait_A
ONE wait_B
</code></pre>

<p>Reflecting back to the trace when everything seemed to be working, we see
that the threads ran smoothly when they managed to lock both locks at once.
But notice how these telltale signs, these skidmarks leading up to the
moment of the crash, show thread one and two locking are always
<em>interleaved</em> when they acquire these locks?</p>

<p>In the first example, thread one acquires mutex A, and before it can lock
mutex B, thread two is scheduled, and comes along and locks mutex B. Then
thread one tries to acquire mutex B and blocks since it is already locked by
thread two, waiting forever, being a patient worker thread.  At this point,
thread two can run again, and tries to acquire mutex A.  Unfortunately, this
lock is held by thread one which is not coming back until it gets mutex B &ndash;
which will never happen.  Because thread two is now blocked forever, waiting
on mutex A.  Your only consolation is that they probably won&rsquo;t consume any
CPU cycles while they remain in this deadlock.  But the program certainly
isn&rsquo;t going anywhere!</p>

<p>So how can this be avoided?  Fortunately, the fix is simple &ndash; always acquire
the mutexes in the same order, and (ideally) release them in the reverse
order.  This fix is an exercise left for the reader, but verify for yourself
that the program will run as long as you like once the locks are acquired in
the same order.</p>

<p>Why does this work?  Because it prevents the possibility of holding a
contested mutex while blocking on another.</p>

<p>Remember: <em>Always acquire multiple mutexes in the same order to avoid
deadlocks.</em></p>

<h1>Exclusive Shared Mutex with Access Semantics</h1>

<p>Source module: <a href="http://bitbucket.org/gavinb/boost_samples/src/tip/mutexes/sharedlock.cpp"><code>sharedlock.cpp</code></a></p>

<p>This example shows how three worker threads can co-operate accessing a
shared resource, where two are reading and the third is writing.  It is
frequently important to manage access in this way, and can drastically
improve performance by increasing concurrency.</p>

<p>If a thread is only reading from a shared resource, it does not require
exclusive access.  Thus many threads can safely obtain read-only access to a
resource.  It is only if a thread needs to write to the resource to update
it that it will need exclusive access, to ensure the data is updated
atomically (as seen by any worker threads) and remain consistent.</p>

<p>Thus by granting multiple threads concurrent read access, concurrency is
increased in proportion to the number of read-only threads.  The only
disadvantage is that any thread wishing to modify the shared resource
(ie. use an exclusive lock) must wait until <em>all</em> reading threads have
finished.  This provides a good incentive to have the scope of the locks as
short as possible, to reduce the time a writing thread would need to wait
for exclusive access.</p>

<p>In this example, A network thread simulates producing data by ading random
numbers to a container.  A display thread shows the data on screen, and a
database thread writes the numbers to a file.  The network thread uses an
exclusive write lock to update the shared data container, while the other
two threads use a shared read-only lock, which means they can both
concurrently access the data safely.  If the network thread tries to access
the data while either of the other two have a read-lock, it has to wait
until all threads release their shared locks.</p>

<p>(Normally a producer-consumer setup such as this would use a Condition
variable to signal when more data is ready, but we&rsquo;re saving that for a
future installment.)</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threading with Boost - Part III: Mutexes]]></title>
    <link href="http://antonym.org//2012/02/threading-with-boost---part-iii-mutexes.html"/>
    
    <updated>2012-02-20T00:00:00+11:00</updated>
    <id>http://antonym.org//2012/02/threading-with-boost&#8212;part-iii-mutexes</id>
    
    <content type="html"><![CDATA[<p>In <a href="http://antonym.org//2009/05/threading-with-boost---part-i-creating-threads.html">Part I</a> of this series on <a href="http://boost.org/">Boost</a> threading, we looked at the basics of how to create and run threads using the Boost libraries.  Then we reviewed the main issues encountered with multithreading code in <a href="http://antonym.org//2010/01/threading-with-boost---part-ii-threading-challenges.html">Part II: Threading Challenges</a>. One of the biggest challenges is safely managing concurrent access to a resource.  A Mutex provides a way to serialise access to a shared resource, such that only one thread is accessing the data at any given time, to ensure your data is consistent.  In this article, we look at how to create and use Boost mutexes.</p>

<!--more-->


<h1>Mutual exclusion &ndash; Mutex</h1>

<p>One of the main solutions to race conditions and other threading problems is the <em>mutex</em>, short for &ldquo;mutual exclusion&rdquo;.  Think of it as a special kind of lock, which is used to protect shared resources.  A mutex is special because it is guaranteed to be held by <em>at most</em> one thread at a time.  While one thread holds a lock on a mutex, no other thread is able to.  Thus mutexes can be used as a protection mechanism for resources and data, by locking before using shared resources and unlocking when finished. A mutex can be used to avoid race conditions, and implement atomic operations.</p>

<p>If a mutex is not locked by a thread, then any thread can potentially lock it.  Once it is locked, if any other thread attempts to lock it, it will typically block and wait until the mutex is unlocked by the owning thread.  It is also possible to return if the lock fails, or wait for a certain period of time before giving up.  These variations are discussed below.</p>

<h2>Mutex Scope</h2>

<p>A mutex is typically declared alongside the resource it protects.  The mutex should be in the same scope as the resource, or an enclosing scope.  For example, a data member in a C++ object that can potentially be accessed by more than one thread at a time should have a mutex declared alongside.  A class instance (static data member) should have a similarly class-scoped mutex.  The shared resource should never have a greater scope than the mutex, otherwise it may not always be protected.  Let us not speak of the blight known as global variables, surely a symptom of deficient design.</p>

<p>In simple cases, a single mutex per object may be sufficient, but this is totally dependent on the algorithms used.  If there are multiple resources being accessed independently, having a single mutex may lead to too much contention.  In this case, a separate mutex for each resource may be more efficient.  Only analysis and performance tests will reveal the more efficient choice.</p>

<p>Any time the resource is accessed (whether for reading or writing), the mutex should <em>always</em> be locked before use, and unlocked after the operation.</p>

<h2>Types of Mutexes</h2>

<p>There are four flavours of mutexes available in Boost, depending on your requirements.  Each are described in detail below, and feature a sample program illustrating its use.  The full source code is available for browsing, downloading or even cloning from my Boost Theading Examples Mercurial repository on <a href="http://www.bitbucket.org/gavinb/boost_examples/">BitBucket</a>.</p>

<h3>Regular Mutex</h3>

<p>The simplest form of mutex is a regular <code>boost::mutex</code>.  You lock and unlock it, and only one thread can lock the mutex at a time.  Any thread that calls <code>lock()</code> on a mutex held by another thread will block indefinitely (an important factor when considering synchronisation).  This is worth repeating: calling <code>lock()</code> can block <em>indefinitely</em>.  This may be the desired behaviour, as your thread may need to wait an undetermined time for something else to happen (but this then raises issues of interruption).  It should be obvious then that this must be carefully managed to avoid program hangs, a common symptom of concurrency failure.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">work_queue_mutex</span><span class="p">;</span>
</span><span class='line'><span class="n">queue</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">work_item</span> <span class="o">=</span> <span class="n">work_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Regular mutexes also have a <code>try_lock()</code> method, which will return immediately with a failure status if the mutex cannot locked.  Since most threads run in a loop, it would be terribly inefficient to try to lock a mutex and then continue around the loop without performing anything else, especially when it is unlikely that the mutex will become immediately available.  In these cases, it <em>may</em> be appropriate to do a short sleep (but see below for a better solution).  Even then, this may be a sign that your algorithm needs improvement.  Unfortunately, there are no one-size-fits-all solutions.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">work_queue_mutex</span><span class="p">;</span>
</span><span class='line'><span class="n">queue</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">try_lock</span><span class="p">())</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">work_item</span> <span class="o">=</span> <span class="n">work_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Do something else...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Timed Mutexes</h3>

<p>The <code>boost::timed_mutex</code> class is a subtype of <code>boost::mutex</code>, which adds the ability to specify a timeout.  For example, you may wish to try to lock the mutex but give up after a certain time if you cannot obtain a lock.  This takes either an absolute time, or a relative time.  If the mutex cannot be obtained within the time specified, the call will return false and the mutex is not held.  If the mutex is locked within the timeout period, it returns true.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">work_queue_mutex</span><span class="p">;</span>
</span><span class='line'><span class="n">queue</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
</span><span class='line'><span class="n">TimeDuration</span> <span class="n">mutex_timeout</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">timed_lock</span><span class="p">(</span><span class="n">mutex_timeout</span><span class="p">))</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">work_item</span> <span class="o">=</span> <span class="n">work_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Recursive Mutexes</h3>

<p>Normally a mutex is locked only once, then unlocked.  Depending on the structure of your application, there may be times when it would be useful to be able to lock a mutex multiple times <em>on the one thread</em> (in very special circumstances, such as nested method calls).  For example, you have two (or more) methods which may be called independently, and another method which itself calls one of the other two.  If they all need the mutex held to function safely, this can cause complications when determining when the mutex needs to be locked and released.  However, by using a recursive mutex, it can be locked as many times as necessary, provided it is unlocked the same number of times.  Thus all these methods can be called individually, as they all lock the resources, and in a nested fashion, as the mutex can be locked multiple times.  Provided the mutex is unlocked the same number of times (which is a matter of care and thought), the mutex will be correctly released by the end of the nested operation.</p>

<h3>Shared Mutexes</h3>

<p>Some concurrency scenarios involve having one writer and many readers.  For example, one thread may be downloading data from the network, while another thread is displaying the data on the screen, and a third thread is saving the data to a database.  So the downloading thread will be locking for writing, and the other two only for reading.  There is therefore no reason why the display thread and the database thread (which both only read the shared resource) need to exclude the other; concurrent reading is perfectly safe.  It is only if the network updating thread needs to write to the shared data that the other two need to be locked out.  This process is shown below:</p>

<!-- @todo Insert diagram here -->


<p>Any time the reading threads need to read the resource, they obtain a read-lock.  This allows other read-locks to successfully access the resource, but will prevent a write-lock (since you don&rsquo;t want updates to occur while someone else is reading &ndash; the data must be consistent).  When an update comes in on the networking thread, it must wait until the readers have finished before it can obtain a write-lock.  This will prevent any readers from accessing the resource for the duration of the update.  In this way, concurrent access is increased, contention is reduced, and the resource is always consistent.</p>

<!-- @todo Insert diagram here -->


<p>One of the example programs shows this in action.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">work_queue_mutex</span><span class="p">;</span>
</span><span class='line'><span class="n">queue</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Reader thread</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">read_lock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">work_item</span> <span class="o">=</span> <span class="n">work_queue</span><span class="p">.</span><span class="n">head</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Writer thread</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">write_lock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">work_item</span> <span class="o">=</span> <span class="n">work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_item</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">work_queue_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Summary</h3>

<p>The table below summarises the difference mutex types, and their main distinguishing features:</p>

<table>
    <tr>
        <td><tt>boost::mutex</tt></td>
        <td>Normal mutex, most commonly used, blocking lock</td>
        <td>has <tt>lock()</tt> and <tt>try_lock()</tt></td>
    </tr>
    <tr>
        <td><tt>boost::timed_mutex</tt></td>
        <td>Adds ability to timeout waiting for a lock</td>
        <td>adds <tt>timed_lock()</tt> to wait for lock with a timeout</td>
    </tr>
    <tr>
        <td><tt>boost::recursive_mutex</tt></td>
        <td>`lock()` can be called multiple times on the *same* thread</td>
    </tr>
    <tr>
        <td><tt>boost::shared_mutex</tt></td><td>lock can be upgraded to allow multiple readers or a single writer</td><td>can upgrade locks (R->W)</td>
    </tr>
</table>


<h2>Lock duration</h2>

<p>It is important that the mutex only be locked for the shortest possible time to ensure data integrity is maintained.  If a lock is held for too long, it may cause other threads to wait excessively, thus stalling processing and negating the benefits of concurrent processing.  Getting the granularity of threading right takes experience and judgement, so learning by studying existing multithreaded code is an excellent way to pick up design patterns.</p>

<p>The next article shows some timing diagrams which illustrate lock contention in simple apps, so you can see just how much time a thread is waiting.</p>

<h2>Lock/Unlock Pairing</h2>

<p>If a mutex is not released due to a logical error (such as an uncaught exception), this may cause the program to lock up or behave strangely, and is probably not recoverable.  Thus it is vitally important that all lock/unlock operations appear in pairs.</p>

<p>To protect against this class of problem, the <code>lock_guard</code> object was introduced.  It locks the mutex for you in its constructor, and unlocks it in the destructor.  (This safety-conscious approach is known as <a href="http://en.wikipedia.org/wiki/RAII">RAII</a>, or Resource Acquisition Is Initialisation, whereby the lifecycle of a resource is tied to the lifecycle of an owning object).</p>

<p>This simple example code shows potentially unsafe method implementation.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">writeTotalsToDatabase</span><span class="p">()</span> <span class="k">throw</span> <span class="p">(</span><span class="n">myapp</span><span class="o">::</span><span class="n">SQLException</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// does SQL stuff, and throws on error</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">unsigned</span> <span class="n">applyTotals</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">mTotalsMutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mTotals</span><span class="p">.</span><span class="n">globalCount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">writeTotalsToDatabase</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mTotalsMutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code looks at first glance to be safe.  It simply makes the updating and saving of the totals atomic, right?  Well, yes &ndash; except if there&rsquo;s an exception thrown by <code>writeTotalsToDatabase()</code>.  If that happens, the normal flow of execution goes out the window, and the program unwinds the stack in search of a suitable <code>catch</code> statement.  And the lock that we have acquired will never be released!  This is very dangerous, and can happen in seemingly &ldquo;safe&rdquo; code.  While you could certainly put a <code>try/catch</code> around the database method, a better way is to use a lock guard.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">unsigned</span> <span class="n">applyTotals</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span>    <span class="n">totalsLock</span><span class="p">(</span><span class="n">mTotalsMutex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mTotals</span><span class="p">.</span><span class="n">globalCount</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">writeTotalsToDatabase</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>totalsLock</code> will acquire (or wait to acquire) the mutex at the start, and when it goes out of scope at the end of the method, it will unlock the mutex.  If an exception is thrown, the lock&rsquo;s destructor will be invoked as part of unwinding the stack, and there the mutex will be safely released.  This ensures the operation is atomic, and can safely handle error conditions.</p>

<h2>Avoiding Deadlocks</h2>

<p>So far, we&rsquo;ve looked at using one mutex at a time.  But a non-trivial application may involve many threads, and even more mutexes.  And what happens when there is contention for mutexes between threads?  There is a fatal error known as a deadlock, and in its simplest form, two threads are holding a resource each, which the other also wants.  Since neither will release one until it gets the other, the threads get stuck waiting forever (or at least until the user gets sick of waiting and kills the process).</p>

<h2>Shared Object with One Mutex</h2>

<p>Imagine you have a shared object, such as a singleton, that may be accessed by multiple threads in the system.  A simple solution to ensure consistent data is returned is to give the object a mutex, and use a lock guard in every method.  For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Baz</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>        <span class="n">Baz</span><span class="p">();</span>
</span><span class='line'>        <span class="kt">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">foo</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>          <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">m_total</span> <span class="o">+=</span> <span class="n">foo</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">getTotal</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>          <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_mutex</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">return</span> <span class="n">m_total</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_mutex</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">double</span>        <span class="n">m_total</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>A note on performance</h2>

<p>Under Linux, the Boost threads implementation uses pthreads and pthread mutexes.  These may use a spinlock at the kernel level, for optimal performance.</p>

<p>Under Windows, a real &ldquo;Mutex&rdquo; object at the operating system level is actually a fairly expensive, heavyweight and slow construct (relatively speaking), mainly intended for intra-process synchronisation.  If you only need serialisation within your process, a &ldquo;critical section&rdquo; is a far better choice, as it is significantly faster.  Fortunately, Boost uses a CritSec for process-level mutexes.  If you need inter-process mutexes, look at the <a href="http://boost.org/">Boost IPC library</a>.</p>

<h2>Other types of Mutexes</h2>

<p>There are a few different flavours of Mutexes, which can be used in more sophisticated scenarios. These are beyond the scope of this article (which is already long enough!).</p>

<h2>Up Next</h2>

<p>The next article will focus on <a href="http://antonym.org//2012/02/threading-with-boost---part-iv-mutex-examples.html">a series of examples showing the use of different mutex types</a>. The source has been published on BitBucket in my <a href="http://bitbucket.org/gavinb/boost_samples/">Boost Sample Code</a> repository.  Feel free to use, fork, and share!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Bug of the Year - 2011]]></title>
    <link href="http://antonym.org//2011/12/bug-of-the-year-2011.html"/>
    
    <updated>2011-12-24T18:24:00+11:00</updated>
    <id>http://antonym.org//2011/12/bug-of-the-year-2011</id>
    
    <content type="html"><![CDATA[<p>My favourite bug of all time was uncovered because I was just too impatient.</p>

<p>I was working on a fairly large and complex embedded project.  A microcontroller
was interfacing with some custom hardware. It would configure, control, and
monitor the hardware.  The microprocessor was running an RTOS with a lightweight
TCP/IP stack, so remote clients could connect to the device via Ethernet and
perform remote configuration.  We also used this for diagnostics and testing
during development.  We had successfully used a similar design on several
products, with great results.  We had also designed a protocol for monitoring
and control that was used in earlier models,  and  we extended it here &ndash; though
this product was significantly larger and more complex than its predecessors.
What could possibly go wrong?</p>

<!--more-->


<p>The first thing the microprocessor does when you connect is to dump the status
of the entire system.  With smaller devices, this was very fast.  But this new
model was so large and had many more components and subsystems, it was taking a
very long time every time you connected. This device can also serve many
concurrent clients, so this slow connection startup would be repeated for every
client.  The processing and time cost was not trivial, and this delay would
limit how quickly clients could start updating their own settings.</p>

<p>Slow and inefficient code bothers me.  Eventually I got sick of waiting a good
10-20 seconds or so every time I connected before I could start working with the
hardware to test my latest changes, so I decided to track down the performance
problem.  As a baseline, I measured the system performance before changing
anything, and then got to work. It had to be something simple, after all &ndash; we&rsquo;ve
had this same code working on other products for many months in the field.</p>

<p>I figured a few hours would probably be enough to solve it.  The debugging
process was made somewhat more difficult by the fact that there was no keyboard
or monitor on this hardware; all debugging was either via JTAG and a serial USB
connection, or by the Ethernet port &ndash; which was part of the problem.</p>

<p>The actual time to solve the mystery would be more like a week, with several
long, late, pizza-fuelled nights, drilling through many layers and thousands of
lines of code to find the <em>very</em> surprising root cause.</p>

<h2>First layer: application protocol</h2>

<p>The most obvious point to start with was the application level buffering. A
protocol layer abstracted away the TCP/IP networking (which also allowed for
serial interfaces) and had its own read and write buffers.  I guessed it might
help to increase the buffer size a little, to have fewer networking calls.  A
little increase didn&rsquo;t help much overall, nor did a big increase.  Ok, so it&rsquo;s
not the protocol buffering.</p>

<p>The status dump on connection has to traverse many data structures, build
strings and create structured text for output.  I reviewed the algorithms,
memory management and improved the code by reducing reallocations and copies,
tidied things up and used pre-allocated buffers more efficiently.</p>

<p>I measured the performance improvement and noticed a modest difference. All that
work helped &ndash; but it was still not enough.  It was just too slow for my liking.
According to my calculations, the system should be capable of <em>much</em> higher
throughput.  I decided to keep digging.</p>

<h2>Second layer: networking and OS</h2>

<p>Underneath the protocol code was a high level interface for networking.  Perhaps
this wasn&rsquo;t as efficient as it could be?  After poring over the code, analysing
potential performance issues, I found a few small issues, but no smoking gun.</p>

<p>Now this RTOS has many tasks (threads) running, only one of which is the
networking support. Could this networking task be getting starved for processing
time? The interrupt handling latency should be guaranteed and well within the
required time.  I disabled all non-essential tasks, tried increasing the
priority of the networking task, and various other tweaks.  None had any impact.
The RTOS kernel was perfectly happy and running smoothly.</p>

<p>Keep digging&hellip;</p>

<h2>Third layer: TCP/IP tuning</h2>

<p>The TCP/IP stack we were using has a boatload of parameters you can configure at
build time, including its internal buffers.  This was a prime candidate for
performance issues. I dug up the documentation, went through our configuration,
and sure enough &ndash; bingo!  Several parameters were not at the recommended values
for this version of the library. Some buffer sizes needed to be multiples of the
packet sizes (eg MSS), and tuned to match other significant parameters.  This
could have caused fragmented packets or memory buffers, and introduce small but
potentially disruptive delays to the flow.</p>

<p>This tuning process took many many hours, and eventually resulted in a decent
improvement in throughput.  But was it enough?  No &ndash; the big dump when the
connection was established wasn&rsquo;t just slow now, it was noticeably jerky and
very <em>bursty</em>. I really needed to see exactly what was happening between the two
socket endpoints.  I needed to understand why it was bursty &ndash; and fix it.</p>

<h2>Fourth Layer: On the Wire</h2>

<p>Having calculated the theoretical peak throughput, I decided there was no good
reason this microprocessor shouldn&rsquo;t be able to maintain a <em>much</em> higher level
of throughput.  Time to do some low-level packet analysis.</p>

<p>I set up Wireshark and started capturing packets.  At first, everything seemed
ok but looking at the timestamps showed clearly that the transmissions were very
bursty.  Sometimes there were delays of a few <em>seconds</em> between packets! No
wonder it was taking so long for a full status dump&hellip; but what was causing
this?</p>

<p>Looking at the IP layer, I decoded and inspected the session piece by piece,
from the very first packet. <code>SYN, SYN-ACK, ACK...</code> All good so far.  But after
transmitting only a few data packets: <code>NAK</code>. Retries? Backoff? Delays! What on
earth was going on?  The trace showed the micro was resending packets it had
successfully sent. Yet by matching up the sequence numbers, it showed the
packets were being <code>ACK</code>ed by the other end. Eventually after receiving a few
out-of-order packets, the receiver tried to back off by increasing timeouts.
This perfectly illustrates the bursty nature of the traffic.  But what could
be causing it?</p>

<p>Not leaving anything to chance, I tried changing Ethernet cables to make sure
it wasn&rsquo;t a dodgy connection causing the fault.  No dice.</p>

<p>At this point, my best hunch pointed to a bug in the TCP/IP library.  Resending
an already acknowledged packet? Madness! Since we had found bugs in this library
before, it was quite conceivable.  I upgraded the stack to the absolute latest
version and reran all the tests.  Same problem.  Yet according to the forums and
bug tracker, nobody else had reported this kind of problem with this stack
before.</p>

<p>I decided some major action was needed.  I needed to partition the problem and
eliminate large components to isolate the fault.</p>

<h2>Isolation</h2>

<p>First stop, to write a simple socket server which would accept a client
connection, and then send out packets in a tight loop, as fast as it could. This
would exercise the TCP/IP stack, driver and hardware without any of the protocol
or application code. The packets contained a monotonic counter so I could see if
any packets were being corrupted or lost.</p>

<p>Running this test and capturing packets on the wire revealed the same problem. A
burst of traffic, a flurry of <code>ACK</code>s and <code>NAK</code>s followed by timeouts and
resends. Curses, foiled again!</p>

<p>Ok, how do I eliminate the TCP/IP stack from the equation?  I constructed a UDP
ping packet by hand, using parts of the wire capture data to fill in the
relevant fields (such as MAC addresses).  I kept a monotonic sequence counter
and copied this into the binary ping blob at the correct offset, which I passed
directly to the driver, with my workstation hardcoded as the destination.  I
started with a small delay, in the order of 100ms between ping packets.  This
seemed to work ok.  But as I decreased the delay, packets were being dropped.
Dropped?!</p>

<p>The only thing between this test and the wire is the device driver and hardware.
Could the driver be corrupting or dropping packets?</p>

<h2>Fourth layer: device driver</h2>

<p>A code review of the device driver didn&rsquo;t show up anything suspicious.  Looking
at the memory management, interrupt handling &ndash; it all seemed quite carefully
written. Many hours later, no closer to the problem.</p>

<p>I pulled up the datasheet for the Ethernet controller and started querying the
status registers, halting the microprocessor and printing a diagnostic. There
were no clear errors to be found, so the driver did not appear to be causing the
hardware to fail sending or receiving data.</p>

<h2>Fifth layer: hardware</h2>

<p>The microprocessor has onboard Ethernet support, which is connected to a
separate MAC (Media Access Control) chip.  This MAC performs the actual
electrical interfacing, and is the last piece of silicon before the wire. I
started reading the datasheet and looking at the initialisation sequence in the
driver, which configures the registers in the MAC on powerup.  I verified the
correct register flags and values, but while I was reading I noticed there were
some counter registers which collected counts of certain types of media
(physical layer) errors.</p>

<p>I added some code to my minimalist hand-crafted ping test to read these counters
from the MAC registers, showing the values before and after the ping burst. Sure
enough, the counters were 0 on powerup, and after the ping test one of the error
counters had a very large number.  Ok, I think we&rsquo;re finally on to something&hellip;</p>

<h2>Back on the wire</h2>

<p>I modified the test program to send out hand-crafted <code>ARP</code> packets. The only
other code in play was the driver.  I went back to Wireshark and captured
another session.  This time, I exported the trace data to a file and analysed
the timing information in the headers.</p>

<p>I then stepped through and counted the number of successful packets sent before
a failure.  Then the next, and the next.  And I started to notice a sort of
pattern. The gaps were something like 9, 17, 33, 51&hellip; and eventually it would
come back down and repeat.  A regular pattern is very interesting, but what
could be causing this kind of failure?</p>

<p>Stepping back and looking at the regular pattern of successes and failures over
time was like looking at an interference pattern.  Like ripples in a pond,
where the waves met, packets were dropped.  A colleague observed that this
looked a bit like there were two slightly different frequencies involved&hellip;
Wait a minute!</p>

<h2>Don&rsquo;t blame the Hardware</h2>

<p>It was nearly midnight, and I desperately wanted to talk to the Hardware
Engineer who designed the system.  But it would have to wait until the morning.
I fired off an email explaining what we had found, and went home exhausted.</p>

<p>The next day, I walked up to the Hardware Engineer who had a big grin on his
face. &ldquo;I think I found your problem&hellip;&rdquo;, he opened.  I was skeptical, but
excited and urged him to explain.  &ldquo;In the last board spin, I rerouted the clock
source of the MAC controller.  So the Microprocessor and the MAC were actually
running off two different clocks!&rdquo;</p>

<p>I was elated.  This perfectly explained the &ldquo;interference pattern&rdquo; we had
observed. The frequencies of the two clocks were supposed to be the same, but
were not perfectly aligned. Even a slight difference in frequency would cause a
&lsquo;beating&rsquo; effect as they drifted in and out of phase.  Much like you can hear
when tuning a guitar, and two strings are almost, but not quite, in tune and you
hear a lower frequency &lsquo;wow&rsquo;.</p>

<p>So &ndash; while the two clocks were aligned, the microprocessor and the MAC
controller chip could reliably communicate, and the packets flowed normally. But
as the clocks drifted slightly out of phase, their chip-to-chip communication
was corrupted as the rising and falling signals between them became misaligned.
This explained why packets appeared to be sent or received at the higher layers,
but were in fact lost in the intermittently garbled transfers.  It&rsquo;s almost a
marvel TCP/IP worked at all!</p>

<h2>The fix</h2>

<p>In the end, it was a simple matter of ensuring both chips used a common clock
source &ndash; which required a modificaiton to the PCB routing.  But for now, to test
the issue, the Hardware Engineer broke out the soldering iron and fixed the
routing by hand on our development system. (We were fortunate that the clock
signal was on an outer layer of the PCB!)  I started the test again, very
nervous to see the results. After days of chasing ghosts, I didn&rsquo;t want to get
my hopes up.</p>

<p>It worked.  The hand-crafted arp and ping tests would run for as long as we
liked, and never skipped a beat, running as fast as it could go.  Finally, full
throughput was achieved.  I queried the registers for protocol and link errors,
and it was all good.  I checked the TCP/IP layer diagnostics for errors and
statistics, and there were no red flags. I went back to the original application
firmware and tested out the protocol, monitoring the wire for good measure.</p>

<p>This time, it took less than a second for a full status dump. Finally &ndash; success!</p>

<h2>Wrapup</h2>

<p>So &ndash; what began as a seemingly simple software performance problem eventually
turned out to be caused by a hardware design fault.  And it revealed several
other opportunities for improvement along the way.  This was a great learning
experience, and a very satisfying puzzle to solve!</p>

<p>Random thoughts:</p>

<ol>
<li>TCP/IP is <em>really, really</em> good at surviving unreliable hardware and problems in layers below.</li>
<li>Don&rsquo;t mix clock sources between chips!</li>
<li>Don&rsquo;t assume that the first problem you find is <em>causing</em> the problem.</li>
<li>Don&rsquo;t assume the improvement you make is sufficient. Measure!</li>
<li>Performance is relative. What can you reasonably expect from the system in front of you?</li>
<li>Performance tuning is all about careful measurments and consistent tests. And changing
one thing at a time!</li>
<li>It&rsquo;s hardly ever the fault of the OS. But it could be. And it&rsquo;s hardly ever the fault of the
hardware. But it could be.</li>
<li>Don&rsquo;t be satisfied with a fix until you understand <em>how</em> it works and <em>why</em> it fixes the problem.</li>
<li>It is sometimes possible to diagnose hardware problems through analysing software.</li>
<li>Persistence usually pays off!</li>
</ol>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Good Code Gardening]]></title>
    <link href="http://antonym.org//2011/03/good-code-gardening.html"/>
    
    <updated>2011-03-09T12:09:00+11:00</updated>
    <id>http://antonym.org//2011/03/good-code-gardening</id>
    
    <content type="html"><![CDATA[<p>During a code review at work recently, we had an interesting discussion about code maintenance.  You could say that coding is a bit like gardening: while you are planting new seedlings, do you weed nearby areas as you go, or save up all the weeding for the next sunny weekend?  Should code maintenance be a continual, gradual process, or does it warrant being scheduled as a task in its own right?</p>

<!--more-->


<p>First, let us define &ldquo;code maintenance&rdquo; as editing source code to make <em>non-functional changes</em>, such as:</p>

<ul>
<li>fixing formatting</li>
<li>fixing whitespace</li>
<li>improving consistency</li>
<li>correcting typos</li>
<li>commenting</li>
<li>minor refactoring</li>
<li>removing dead code</li>
</ul>


<p>In general, these sorts of changes are improving code hygiene, tasks which are not normally scheduled or allocated.</p>

<p>Now, the problem is this: imagine you are working on a large codebase, which has been around for quite some time, and has had a variety of authors modifying it.  As you are working on a new feature, you are adding new code, and refactoring existing code to enable the new code to work.  Suppose you come across some old, dead code. Should you remove it right now?  You see an obvious typo in an unrelated comment.  Should you correct it here?  You notice some inconsistently formatted code.  Should you update its layout before moving on with your main task?</p>

<p>There are only two answers to this seemingly simple question, but there are many important issues that surround it.  Either you fix it now (garden as you go), or save it for later (do it all on Weeding Day).</p>

<h2>Garden as you Go</h2>

<p>Why should do tidy your code as you go?</p>

<ul>
<li>You may forget to come back and do it later</li>
<li>You might run out of time to do later, as another bug or feature will take priority</li>
<li>A patch with a few extra whitespace changes or comment edits is trivial and takes hardly any time to review</li>
<li>As the code gradually expands, it is incrementally and constantly improved</li>
<li>Code hygiene improves code quality</li>
</ul>


<h2>Weeding Day</h2>

<p>Why should you do your weeding separately?</p>

<ul>
<li>Mixing code maintenance in with new code in a single patch obscures the actual intent, and the patch is no longer one discrete piece of work</li>
<li>Unrelated changes may make it more difficult to merge</li>
<li>Reviewing code for unrelated changes can waste reviewers&#8217; time</li>
<li>Maintenance is important, and should be scheduled as a discrete work item</li>
<li>Maintenance needs to make the code more consistent, so it should be done in one hit</li>
</ul>


<h2>The Verdict</h2>

<p>The conclusion I came to is a kind of compromise, but ultimately driven by the notion that the sanctity of the patch is the most important factor.  One patch should always be a discrete piece of work, so mixing new features and gardening/maintenance into one patch is a bad idea.</p>

<p><strong>But</strong> the argument that it is very hard to <em>schedule</em> maintenance time is a compelling one, as there is invariably a huge backlog of bug fixes or new features waiting which take priority.  With all the best intentions in the world, most managers will rather have you working on new features and bug fixes than touching code that already works.  So maintenance doesn&rsquo;t get scheduled.</p>

<p>So if you don&rsquo;t perform code maintenance as you go, when do you do it?  You do it as you go!  Let me explain&hellip;</p>

<p>You perform your code gardening/maintenance as you go, but you <strong>commit your maintenance changes separately</strong>.  Feature work goes into one patch (or changeset or commit), bug fixes go into their own patch (maybe with a regression test), and maintenance goes in its own patch.  That way, each patch can be reviewed without any distractions, merges are simpler, and you still get continual improvement.</p>

<h2>Howto: In Depth</h2>

<p>A good craftsperson has good tools, and my proposed solution requires good tool support to be truly effective.  Ideally, You will be using a powerful version control system (VCS) such as <a href="http://mercurial.selenic.com/">Mercurial</a> or <a href="http://git.kernel.org/">git</a> (unfortunately <a href="http://subversion.tigris.org/">Subversion</a> does not really do what we need, though it can be wrangled with some effort).  Both these tools allow you to check in changes not only at the level of an individual file, but at the level of changed <em>hunks within a file</em>.  This lets you more easily manage a <em>subset</em> of the current outstanding changes in your source tree.  So the idea is that you can go ahead and do maintenance all over the place, knowing your patch will end up nice and clean and separate from the maintenance work.</p>

<p>So how do you this?  Imagine you have a tool with the following files:</p>

<pre><code>fileio.c
fileio.h
parser.c
parser.h
main.c
utils.c
utils.h
</code></pre>

<p>You need to modify the file loading support to fix a bug with handling metadata in the headers.  So you modify <code>fileio.c</code> and <code>fileio.h</code>.  Along the way, you need to modify <code>render.c</code>, and along the way add some debug code to the rendering code.  This last change is of course throwaway test code that you will never check in.  And while you&rsquo;re hacking away adding tracing statements, you notice some dodgy comments, which don&rsquo;t match with the code.  So you fix those, and keep going &ndash; only to find someone managed to insert some hard tabs in there by mistake (after all, who would do that on <em>purpose</em>?).  So you use the Emacs <code>untabify</code> function to clean up that region too.  The renderer code uses some functions in the <code>utils</code> module, and you notice the docstring is missing an explanation of the parameters, so you add some <code>@param</code> statements while you&rsquo;re there.  Now your VCS will give you the following status (Mercurial output):</p>

<pre><code>M fileio.c
M fileio.h
M render.c
  render.h
  main.c
  utils.c
M utils.h
</code></pre>

<p>And if you looked at the overall diff, it would mix in a bunch of unrelated changes in with your file loading fix.  You&rsquo;re two degrees removed from the original problem by the time you get to <code>utils</code>.  But all these changes are worthwhile, and improve the code.  You don&rsquo;t want to lose them.</p>

<p>So you simply don&rsquo;t check in <code>utils.h</code> at all.  That&rsquo;s easy (and even <code>svn</code> can cope with that).  And you commit all of the changes to <code>fileio</code>, as those make up the fix you were working on in the first place.  But what about <code>render.c</code>?  You&rsquo;ve got no less than <em>three</em> types of changes in there:</p>

<ul>
<li>temporary debug code (that will be removed later)</li>
<li>maintenance changes (to fix up the comments and whitespace)</li>
<li>bug fix changes (part of the file I/O fix)</li>
</ul>


<p>If you&rsquo;re using Mercurial (my DVCS of choice), you can use the <code>record</code> command (a built-in extension)
to easily check in individual hunks (sub-parts of diffs).  You use <code>record</code> much like commit, except instead of committing all your outstanding changes, it will interactively prompt you on a per-file and then a per-hunk basis.  You can nominate to include all of a file&rsquo;s changes, skip it entirely, or choose hunks.  This way, you can add both the <code>fileio</code> files, skip <code>utils</code> and choose only the bug fix changes that ended up in <code>render.c</code>.</p>

<pre><code>$ hg record -m "Bug fix for #123, validate metadata type and length before loading"
</code></pre>

<p>You will end up with the changes <em>just</em> for the bugfix in this one commit, making it nice and easy to send off to review.  And then you have the other changes remaining:</p>

<pre><code>  fileio.c
  fileio.h
M render.c
  render.h
  main.c
  utils.c
M utils.h
</code></pre>

<p>which you can then selectively commit at your leisure.</p>

<p>The following animation shows this process for a single file:</p>

<p><img src="http://antonym.org//img/Gardening.gif"></p>

<p>If you&rsquo;re using <code>git</code>, there is a command that performs essentially the same thing.  You need first to add your desired changes to the &ldquo;index&rdquo; (or staging area).  You can even stage changes as you go, which is a very powerful (though potentially confusing) model.  This is performed with:</p>

<pre><code>$ git add --interactive
</code></pre>

<p>Once you have chosen the hunks that make up the desired patch, you can commit what is in the staging area and the diff for that changeset will be nice and clean.</p>

<p>Fortunately, there&rsquo;s also GUI support for these operations.  For example, the most excellent <a href="http://gitx.frim.nl/">GitX tool</a> allows you to not only select individual hunks for commit, you can even split up hunks and control which individual lines are committed (or staged).</p>

<p>This discussion highlights the need for good tools to support your workflows (rather than have your tool dictate your workflow).  Stay tuned for an upcoming article on &ldquo;Coding vs Patching&rdquo;, exploring the idea that the practice of coding is very much about shepherding clean patches from inception through to review and final merging.</p>

<p>So &ndash; go be a Good Gardener&hellip;</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[25 Tips for Intermediate Mercurial Users]]></title>
    <link href="http://antonym.org//2010/04/25-tips-for-intermediate-mercurial-users.html"/>
    
    <updated>2010-04-07T23:58:00+10:00</updated>
    <id>http://antonym.org//2010/04/25-tips-for-intermediate-mercurial-users</id>
    
    <content type="html"><![CDATA[<p>I recently read an interesting article by Andy Jeffries entitled <a href="http://andyjeffries.co.uk/articles/25-tips-for-intermediate-git-users">25 Tips for Intermediate Git Users</a> (linked to via <a href="http://www.reddit.com/r/programming/">proggit</a>) .  It had lots of useful information condensed into bite-sized task-oriented chunks.</p>

<p>I&rsquo;ve been using <a href="http://mercurial.selenic.com/">Mercurial</a> for a while now, so I thought I would write a similar set of tips by translating from <code>git</code> to the equivalent <code>hg</code> commands.  Thanks to Andy for blessing this translation work.  There may well be some mistakes herein &ndash; please leave a comment if you have any improvements or fixes to suggest.</p>

<!--more-->


<h1>Basic Tips</h1>

<h2>1. First Steps After Install</h2>

<p>Once you have <a href="http://www.selenic.com/mercurial/download/">installed Mercurial</a>, you should create the <code>.hgrc</code> file in your home directory which contains your default user configuration.  This is where you can customize options and load additional <a href="http://www.selenic.com/mercurial/wiki/Extensions">extensions</a>.  The absolute minimum is to specify your name and email address, which is recorded in every commit you make:</p>

<pre><code>[ui]
username = Joe Coder &lt;joe@example.com&gt;
</code></pre>

<p>To enable extensions, add a section called <code>[extensions]</code> and list the names.  I would recommend the following extensions, which are incredibly useful.  Just add another section to your config file:</p>

<pre><code>[extensions]
graphlog=
pager=
color=
fetch=
record=
bookmarks=
</code></pre>

<p>To configure an extension, add a section with its name, and the options within.  For example, to configure the <code>pager</code> extension, you should configure it to not interfere with certain interactive commands.  Something like this:</p>

<pre><code>[pager]
pager = LESS='FSRX' less
ignore = version, help, update, serve, record
</code></pre>

<p>For complete information about this file, see:</p>

<pre><code>$ hg help config
</code></pre>

<h2>2. Mercurial is tree-based</h2>

<p>Mercurial stores its repository in the &ldquo;revlog&rdquo; format.  This is a tree of commits and their metadata, with each commit being uniquely identified by its the SHA-1 hash.</p>

<p><img src="http://antonym.org//img/MercurialRevisionTreeExample.png"></p>

<p>When you see a changeset in this format:</p>

<pre><code>4225:cf1a9b1f9bee
</code></pre>

<p>this is showing the simple revision number, <code>4225</code>, and the revision hash, <code>cf1a9b1f9bee</code>.  Either can be used to refer to a revision, and usually the first four characters of the hash are sufficient to uniquely identify a revision.</p>

<p>The simple revision number (akin to the sequentially numbered revisions in <code>svn</code>) is unique to a repository, but not necessarily across repository clones.</p>

<p>Tags are simply labels associated with a revision.  Named branches are stored in the changeset metadata, while bookmarks are much like local tags that move with each commit.</p>

<p>There is always one named branch in existence: <code>default</code>.  This is normally where mainline development occurs, and is equivalent to <code>trunk</code> in Subversion, or <code>master</code> in git.</p>

<h2>3. Two parents &ndash; of course!</h2>

<p>The <code>hg log</code> command lets you view the details of your commit history.  Normally each commit has one parent, which is the path up the tree.  But when you perform a <code>merge</code> operation, you are combining two branches of the tree together.  This is known as a &ldquo;merge commit&rdquo;, and the changeset is recorded as having two parents, referring to the two branches that were merged.</p>

<p>For example, here is a commit from one of my repos showing r32 merging with r30, to produce r33:</p>

<pre><code>.
.
|
|
o    changeset:   33:9710bef2500e
|\   parent:      30:ad3a51b8aa18
| |  parent:      32:a3f98e81c19c
| |  user:        Gavin Baker &lt;gavinb@...&gt;
| |  date:        Mon Nov 09 07:47:15 2009 +1100
| |  summary:     Merged udp log work from deadlock branch
| |
| o  changeset:   32:a3f98e81c19c
| |  branch:      deadlock_gb
| |  user:        Gavin Baker &lt;gavinb@...&gt;
| |  date:        Mon Nov 09 07:43:51 2009 +1100
| |  summary:     Started adding udp logging
| |
. .
. .
</code></pre>

<h2>4. Merge conflicts</h2>

<p>Mercurial can be configured to use an external tool to process three-way merges.  For example, to use the popular <code>kdiff3</code> tool, add the following section to your <code>.hgrc</code>:</p>

<pre><code>[merge-tools]
# Override stock tool location
kdiff3.executable = ~/bin/kdiff3
# Specify command line
kdiff3.args = $base $local $other -o $output
# Give higher priority
kdiff3.priority = 1
</code></pre>

<p>If you don&rsquo;t have an external merging tool, mercurial will save the left and right versions of the files, and place conflict markers (&ldquo;&lt;&lt;&lt;&lt;&rdquo;, &ldquo;&mdash;&ndash;&rdquo;, &ldquo;>>>>&rdquo;) in the working copy.  It is up to you to then edit the file, resolve the conflict, and then resolve or commit your changes.  To mark a conflicted file as resolved:</p>

<pre><code>$ hg resolve -m main.c
</code></pre>

<p>To check the status of files involved in the merge:</p>

<pre><code>$ hg resolve -l
</code></pre>

<h1>Servers, Branching and Tagging</h1>

<h2>5. Remote servers</h2>

<p>In Mercurial, every repository is self-contained and includes the full history of the project.  When you <code>clone</code> a repository, the URI of the original is stored in the repository&rsquo;s own <code>hgrc</code> file (stored in the <code>.hg</code> directory at the root of the repository).  In the section labelled <code>paths</code>, an entry is created called <code>default</code>, which points to the original repo.  This way, you do not have to specify a URI for certain commands that involve remote repositories.</p>

<p>To see which changes have been made in the default remote repository since you last updated:</p>

<pre><code>hg incoming
</code></pre>

<p>To see which changes you have locally that have not yet been pushed to the default remote repository:</p>

<pre><code>hg outgoing
</code></pre>

<p>You can always add more entries to the remote server list by editing the <code>.hg/hgrc</code> file.  These are simply aliases for the full URI, which you can use along with commands that need a repository path.  For example, given the following entries in the <code>.hg/hgrc</code> of a given repo:</p>

<pre><code>[paths]
goog = http://code.google.com/p/golang/
exp = https://bitbucket.org/gavinb/golang-exp/
</code></pre>

<p>the following sets of commands are equivalent:</p>

<pre><code>$ hg incoming http://code.google.com/p/golang/
$ hg incoming goog

$ hg outgoing https://bitbucket.org/gavinb/golang-exp/
$ hg outgoing exp
</code></pre>

<p>Open questions:</p>

<ul>
<li>Is there an extension equivalent to <code>git remote</code> for managing paths?</li>
<li>How do you compare just a local and a remote branch (not the full set of changesets)?</li>
</ul>


<h2>6. Tagging</h2>

<p>In Mercurial, there are two types of tags: regular tags and local tags.  Regular tags are stored in the <code>.hgtags</code> file in the root of the repository, and are versioned just like any other file.  These tags are also therefore propagated to any remote servers.  You can list all the current tags with:</p>

<pre><code>$ hg tags
</code></pre>

<p>To add a regular tag to the current revision, you simply give it a name:</p>

<pre><code>$ hg tag version_1_3
</code></pre>

<p>To associate a tag with a specific revision, you use the <code>-r</code> option:</p>

<pre><code>$ hg tag -r 4a93 version_1_2_1
</code></pre>

<p><img src="http://antonym.org//img/MercurialTaggingExample.png"></p>

<p>Once you have created a tag, you can use its name virtually anywhere you would normally specify a revision.  So after the above two operations, <code>hg tags</code> would show:</p>

<pre><code>tip                 152:01ae0a9083c3
version_1_3          79;08a49fb329a1
version_1_2_1        22:4a93c0e1aa0b
</code></pre>

<p>A local tag works in almost the same way, except local tags do not get copied between repositories when running a <code>push</code> or <code>pull</code>.  You create a local tag by specifying the <code>-l</code> flag:</p>

<pre><code>$ hg tag -l experimental
</code></pre>

<p>The <code>bookmarks</code> extension also provides a form of local tags, which move with the latest commit.  (Bookmarks are very much like git&rsquo;s cheap local branches, and a topic worth its own article.)</p>

<h2>7. Creating Branches</h2>

<p>Creating a named branch in Mercurial is a matter of simply specifying a branch name, which will be saved in the metadata of the next commit:</p>

<pre><code>$ hg branch bug_fix_5948
</code></pre>

<p>To switch between branches, use the <code>update</code> command with the branch name:</p>

<pre><code>$ hg update gui_changes_experimental
</code></pre>

<p>To display all the current branches, simply issue:</p>

<pre><code>$ hg branches
</code></pre>

<p>The following example shows a feature branch for the GUI, and another for the database layer.  These branches are periodically merged with default, where releases are made:</p>

<p><img src="http://antonym.org//img/MercurialBranchingExample.png"></p>

<p>There are other types of branches too.  The simplest is an &ldquo;anonymous&rdquo; branch, which you can create simply by updating to an earlier revision, making some changes, and committing a new child revision.  This will result in a commit with two children &ndash; ie. a branch.  Steve Losh has written <a href="http://stevelosh.com/blog/2009/08/a-guide-to-branching-in-mercurial/">an excellent article on branching</a> which explains this in more detail.</p>

<h2>8. Merging Branches</h2>

<p>Once the work on your branch is complete, you will want to merge it back to the mainline of development (which is usually <code>default</code>).  To close the branch before you merge, use:</p>

<pre><code># on branch gui_changes_experimental
$ hg commit --close-branch -m "Experimental branch was a success"
</code></pre>

<p>Then you switch back to the target branch into which you want to merge your changes.</p>

<pre><code>$ hg update default
</code></pre>

<p>And then specify the name of the branch to merge, like this:</p>

<pre><code>$ hg merge gui_changes_experimental
</code></pre>

<p>Mercurial will then attempt to automatically merge all the changes, and notify you if there are any conflicts that require manual resolution.  At this point it can also launch a custom merging utility. (See tip #4 above.)</p>

<p>If you would like to see which changesets would be merged from a branch, you can preview the merge using:</p>

<pre><code>$ hg merge -P gui_changes_experimental
</code></pre>

<p>You can see a list of open branches using:</p>

<pre><code>$ hg branches
</code></pre>

<p>And you can see which changes have yet to be merged by doing a diff with the branch name:</p>

<pre><code># on branch default
hg diff gui_changes_experimental
</code></pre>

<h2>9. Remote branches</h2>

<p>By default, when you <code>push</code> your changes to a remote server, you push all commits made since the last update.  To push only a single branch, you can specify its name (or a given revision):</p>

<pre><code>$ hg push -r gui_changes_experimental
</code></pre>

<p>This will push all the changesets starting from the head of the branch, and all its ancestors that do not appear in the remote repository.</p>

<p>As far as I know, there is no direct equivalent to git&rsquo;s tracking branches in Mercurial.</p>

<h1>Storing Content in stashes, etc</h1>

<h2>10. Stashing</h2>

<p>If you are in the middle of a set of changes, and you need to perform an operation on the repository without first committing all of your local changes, you can &ldquo;stash&rdquo; them away and set them aside using the <a href="http://mercurial.selenic.com/wiki/ShelveExtension">shelve</a> extension.  This puts your current set of changes into a temporary storage area, from which you can restore them later.</p>

<p>To save your changes, run:</p>

<pre><code>$ hg shelve
</code></pre>

<p>You can interactively specify which changes to shelve at the granularity level of individual hunks, or simply stash entire files.  To bring your changes back into the working directory, simply use:</p>

<pre><code>$ hg unshelve
</code></pre>

<h2>11. Adding Interactively</h2>

<p>Ideally every commit should be a discrete patch that applies one cohesive change.  But for various real-world reasons, you often find yourself with a working directory that contains modified files containing multiple unrelated changes.  Sometimes it is individual files, sometimes even within the one file.  It would be great to be able to commit a subset of your patches, and choose individual hunks or files to commit.  The <code>record</code> extension does exactly that.  Running:</p>

<pre><code>$ hg record
</code></pre>

<p>interactively shows you each file, and lets you inspect each hunk that has changed, one by one.  You can accept individual hunks to commit, accept or ignore an entire file, and so on.  Any changes you do not commit will remain in your working copy to deal with later.  This is a great way to keep your commits clean and separate.</p>

<h2>12. Handling Large Files</h2>

<p>(There is no direct equivalent to the original list&rsquo;s item #12, &ldquo;Storing/Retrieving from the Filesystem&rdquo;.)</p>

<p>Some projects (games are an excellent example) feature large binary resources, which do not lend themselves well to management under a VCS.  Examples include images, movies, sound files, level data, and so on.  You don&rsquo;t want to keep multiple versions of these files around if you can help it, and performance can suffer for files over about 10MB.</p>

<p>The <a href="http://mercurial.selenic.com/wiki/BigfilesExtension"><code>bigfile</code> extension</a> aims to solve this problem by storing large binary files (Binary Large Objects, or BLOBs) in a separate location, while still allowing you to manage the files using Mercurial.  A sample session looks like this:</p>

<p>*** TODO Insert bigfile example</p>

<h1>Logging and What Changed</h1>

<h2>13. Viewing a Log</h2>

<p>To review the details of your commit history, you use the <code>log</code> command.  A brief one-line summary is displayed with:</p>

<pre><code>$ hg log
</code></pre>

<p>To see the logs for a specific revision, range, tag or branch, use the <code>-r</code> switch:</p>

<pre><code>$ hg log -r9584
$ hg log -r release_1.3
</code></pre>

<p>To show all the details of the metadata, and the full commit message, use the verbose <code>-v</code> switch.</p>

<p>If you want to view the patch itself, use:</p>

<pre><code>$ hg log -p
</code></pre>

<p>If you enabled the <code>glog</code> extension (distributed with Mercurial), you can see a graphical representation (in ASCII art) of the commit tree, showing branches and merges using:</p>

<pre><code>$ hg glog
</code></pre>

<h2>14. Searching the Log</h2>

<p>To display only those changesets which have been committed by a given author, use the following command:</p>

<pre><code>$ hg log -u joe
</code></pre>

<p>You can search for a username, real name or in fact any substring in the &lsquo;author&rsquo; field.</p>

<p>To search for a keyword that appears in the commit message, use:</p>

<pre><code>$ hg log -k regression
</code></pre>

<p>To search for commits that changed certain filenames, you can include or exclude patterns:</p>

<pre><code>$ hg log -I "**/Makefile"
$ hg log -X "*.xml"
</code></pre>

<p>To view all commits made since a given date:</p>

<pre><code>$ hg log -d "&gt;2009-11-1"
</code></pre>

<p>There are many more date options &ndash; see <code>hg help dates</code> for the full list.</p>

<p>The <code>log</code> command can also display the log output using a user-defined template, which can be very useful for scripting and custom reporting.  This example can be used to derive summary statistics of changed files by user:</p>

<pre><code>$ hg log --template "{date}|{user}|{diffstat}" -d "&gt;2009-11-20"
</code></pre>

<p>See <code>hg help templating</code> for the complete syntax.</p>

<h2>15. Selecting Revisions</h2>

<p>There are many ways of specifying a revision when using commands such as <code>log</code>, <code>merge</code>, and so on.</p>

<pre><code>$ hg log -r 4281               # By short revision number
$ hg log -r d1b75410b793       # By full revision number (SHA-1 hash)
$ hg log -r feature_213        # By branch name (refers to head of branch)
$ hg log -r release_1_31       # By tag name
$ hg log -r refactor_engine    # By bookmark name
</code></pre>

<p>If you install the <a href="http://mercurial.selenic.com/wiki/ParentrevspecExtension"><code>parentrevspec</code> extension</a>, you can also use git-style relative revisions, such as <code>foo^^</code> for the second parent of revision <code>foo</code>.</p>

<h2>16. Selecting a range</h2>

<p>To specify a range of revisions to a command taking a <code>-r</code> revision range, use the syntax <code>[BEGIN]:[END]</code>.  If <code>BEGIN</code> is not specified, it defaults to revision 0, and if <code>END</code> is not specified, the <code>tip</code> revision is used.  A single <code>:</code> by itself refers to all history.  You can even specify the revisions in reverse order, if <code>END</code> is less than <code>BEGIN</code>.  Again, a revision can be specified using any style as per tip #15 above.</p>

<h1>Rewinding Time and Fixing Mistakes</h1>

<h2>17. Resetting changes</h2>

<p>If you have modified a file in your working directory, but you wish to discard the changes and not commit them, you can use:</p>

<pre><code>$ hg revert parser.c
</code></pre>

<p>If you just committed a change that you didn&rsquo;t intend, you can back out that change.  (Note that this will only work if the commit was the very last transaction you applied.)  You run:</p>

<pre><code>$ hg rollback
</code></pre>

<p>The working copy will be back to where it was before the commit, and the commit will be deleted from the repository.</p>

<p>If you want to delete an entire branch, you can do so (provided you have the <code>mq</code> extension enabled) using:</p>

<pre><code>$ hg strip -r 432
</code></pre>

<p>This will remove revision 432 <em>and all its descendants</em> from the repository.  So it is just like pruning a branch from a tree.  Note that this is a very destructive operation!  For your safety, Mercurial will store the stripped changesets into a bundle, so you can reapply the bundle if you made a mistake.</p>

<p>The preferred way of undoing the effect of an older commit is to use:</p>

<pre><code>$ hg backout -r 9684
</code></pre>

<p>This will create a new changeset that reverses the effect of the specified revision.  It may create a new head (depending on the working directory&rsquo;s parent), in which case you can merge the new head into default.</p>

<h2>18. Committing to the wrong Branch</h2>

<p>If you&rsquo;ve made a bunch of changes, then committed them to the wrong branch in multiple versions, all is not lost.  While <code>hg rollback</code> will undo the last transaction (ie. commit), it cannot reverse more.</p>

<p>If you want to undo the changes in one changeset, use:</p>

<pre><code>$ hg backout
</code></pre>

<p>which will create a new changeset that reverses the effect of the specified revision.  This will normally create a new head, so you will need to merge this into <code>tip</code>.</p>

<p>If you have committed a series of changesets, you could also run <code>hg strip</code> from the errant revision to remove it from the tree.  Then switch to the correct branch, take the bundle file that <code>strip</code> saves for you, and apply the bundle.</p>

<h2>19. Interactive Rebasing</h2>

<p>The <a href="http://mercurial.selenic.com/wiki/HisteditExtension"><code>histedit</code> extension</a> provides similar functionality to git&rsquo;s powerful <code>rebase --interactive</code> command.  It allows you to take a series of changesets, and commit, fold into a previous commit, edit or drop each revision.  It will then reorder and reapply the changesets in the specified manner.</p>

<p>This can be useful for cleaning up a feature branch before merging, for example.  Note that this does involve modifying existing changesets, so be careful to do it before pushing the changes to another repo.</p>

<h2>20. Cleaning up</h2>

<p>To clean up your working directory and remove files not under version control, you can display a list of untracked files (<code>-u</code>) without displaying the status (<code>-n</code>), then pipe the results to a command to delete them:</p>

<pre><code>$ hg st -nu | xargs rm
</code></pre>

<p>If you want to clear away all the files in your working directory (but otherwise leave your repository intact) use:</p>

<pre><code>$ hg checkout null
</code></pre>

<p>All tracked files will be removed, leaving your working copy empty (but of course the repository still intact).  This can be useful on servers, in clones, and to save space in older projects.</p>

<h1>Miscellaneous Tips</h1>

<h2>21. Previous References You&rsquo;ve Viewed</h2>

<p>(This doesn&rsquo;t apply to hg.)</p>

<h2>22. Branch Naming</h2>

<p>Branch names can contain the usual characters, such as a-z, A-Z and numeric characters.  But you can also use other punctuation characters, so you can create a psueo-namespace:</p>

<pre><code>$ hg branch experimental/parsing_performance
</code></pre>

<h2>23. Finding Who Dunnit</h2>

<p>It can be very useful to see who made a particular change in a file.  The <code>annotate</code> command will display a file, and annotate each line with the revision and author of the last modification.  (This command is often known as the <code>blame</code> command, as you probably want to know who broke the build.)</p>

<h2>24. Repository Maintenance</h2>

<p>The Mercurial repository format (&ldquo;reflog&rdquo;) is designed to be reliable and efficient.  Unlike the git storage format, it does not require ongoing maintenance (such as garbage collection).</p>

<p>Since file systems and hard drives are fallible, it is possible that an error could corrupt a repository.  To verify the integrity of the repository, run:</p>

<pre><code>$ hg verify
</code></pre>

<p>This will perform an extensive series of tests, and report the results.</p>

<h2>25. Ignore files by pattern</h2>

<p>Your working directory can often become cluttered with generated or intermediate files that you do not want to check in to your repository.  You can add a list of files to ignore, either for all repos (by adding it to your <code>~/.hgrc</code>) or selectively for a given repository (by editing <code>.hgignore</code> in the root of your repo).  You can use either a simple globbing form, or a full regexp specification.  Here&rsquo;s an example:</p>

<pre><code>syntax:glob
*.o
*.a
*.dylib
*.pyc
*.res
*~
</code></pre>

<p>This tells Mercurial to simply ignore these files.  If you are using Xcode, you will want to exclude the build product tree entirely, and also the per-user project settings (which change frequently and don&rsquo;t really need to be under version control):</p>

<pre><code>build/*
MyProject.xcodeproj/*.pbxuser
MyProject.xcodeproj/*.mode1v3
</code></pre>

<h2>26. Bonus: Built-in Web Server</h2>

<p>Thanks to its Python foundation, Mercurial features a built-in web server.  You can browse the revision history, review metadata, display a graphical timeline view, list tags and branches, and view file lists and contents.  It is fully configurable, with different styles and templates.  But to get up and running very quickly, simply run the following command:</p>

<pre><code>$ hg serve -d -n myproject
</code></pre>

<p>The <code>-d</code> will daemonise the server, which will run it in the background.  By default, the server listens on port 8000, so simply fire up your browser and point it to:</p>

<pre><code>http://localhost:8000/
</code></pre>

<p>and that&rsquo;s it!  You can run multiple instances, install it alongside Apache, and have it run a webdir serving multiple repositories.  It&rsquo;s very powerful and useful.</p>

<h1>Closing</h1>

<p>I hope this is a useful set of tips.  Thanks again to Andy for the original <code>git</code> document.  Please leave a comment or drop me an email if you have any suggestions or improvements for the above.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threading with Boost - Part II: Threading Challenges]]></title>
    <link href="http://antonym.org//2010/01/threading-with-boost---part-ii-threading-challenges.html"/>
    
    <updated>2010-01-01T21:15:00+11:00</updated>
    <id>http://antonym.org//2010/01/threading-with-boost&#8212;part-ii-threading-challenges</id>
    
    <content type="html"><![CDATA[<p>In <a href="http://antonym.org/">Part I</a> of this series on <a href="http://boost.org/">Boost</a>, we looked at the basics of how to create and run threads using the Boost libraries.  But once you have more than one thread running in a process, you have to deal with the problems and challenges that threads can introduce.  So, before delving into the mechanics of how to use mutexes and other threading constructs, we look at what can go wrong &ndash; and how to avoid it.</p>

<!--more-->


<h2>Shared State</h2>

<p>There is a simple solution to most major threading problems: have no shared state.  By shared state, I mean any data or resource (such as file handle, socket, graphics context, queue, buffer, etc) that is used by more than one thread at the same time.  If two threads are truly independent, they can safely run concurrently without care or consideration.  We wouldn&rsquo;t need sophisticated mechanisms for synchronisation if there&rsquo;s nothing to sync over.  Unfortunately, this restriction is not at all practical or realistic.  And as soon as you introduce shared state, you have to worry about atomicity, consistency, race conditions, and all sorts of issues.</p>

<p>So one of the first design considerations for concurrent systems is to try to minimise the amount of shared state between threads.  The less shared state, the less complexity there is to manage, and the less overhead imposed. Locks that protect shared resources can harm performance: each lock is a region that enforces sequential access, and thus reduces the opportunities for concurrent scheduling.</p>

<p>Simply put, any resource shared between more than one thread needs to be protected by a mutex, such that access is serialised.</p>

<p>When considering scalability, the theoretical maximum speedup of N cores is always less than N times, due to scheduling and synchronisation overheads.  Thus the most efficient algorithm designs consider these issues up front.</p>

<h2>Problem: Atomicity</h2>

<p>An operation is <em>atomic</em> if the operation completes without interruption.  It is never partially complete, which may leave the system or data in an inconsistent or invalid state.  Atomic operations come up all over the place, and even things that we might <em>think</em> are atomic (ie. a single line in your source) probably isn&rsquo;t.  In databases, we use SQL transactions to ensure operations are atomic, such that a related set of changes are never partially applied.</p>

<p>The classic example of an atomic operation in a database is a bank transfer.  You decide to pay your landlord by direct deposit, and transfer $1200 to their account.  The normal sequence of operations is:</p>

<ol>
<li>Ensure you have sufficient funds</li>
<li>Ensure the receiving account number is valid</li>
<li>Withdraw the $1200 in funds from your account</li>
<li>Deposit the $1200 in the landlord&rsquo;s account</li>
</ol>


<p>Now the first two steps are really preconditions, and while they are necessary for the entire operation&rsquo;s success, if the operation was cancelled after step 1 or step 2, there would be no harm done, and nothing changed.  But once the money comes out of your account after step 3, you absolutely want step 4 to complete, otherwise you are $1200 out of pocket and you <em>still</em> owe the rent!  So steps 3 and 4 <em>must</em> either both happen successfully, or not at all.  If the network goes down between steps 3 and 4 such that the deposit cannot complete, you want to undo the withdrawal and try again later.  Steps 3 and 4 must be performed atomically.</p>

<p>While this example traditionally applies to database operations (and is thus resolved on-disk), the same concept applies to in-memory operations that must be atomic.  A <em>mutex</em> (for &ldquo;mutual exclusion&rdquo;) or <em>critical section</em> can be used to serialise access to resources within a region of code that must run as an atomic operation. We would lock the mutex before the transaction, and unlock it afterwards.</p>

<h2>Problem: Race Conditions</h2>

<p>A <em>race condition</em> is a general term for a class of problems, whereby the result of an operation is at the mercy of the timing of concurrent events (typically unknown or effectively random).  This is bad because your program becomes non-deterministic &ndash; it may not always produce the correct result!  They represent one of the most subtle and difficult to debug problems in software development, which is one of the main reasons why multi-threaded programming is considered difficult.</p>

<h3>Example: A Counter</h3>

<p>Even a simple increment operation, which is only a single operation in C++, may actually be the source of a race condition.  Consider the seemingly innocent:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">m_SequenceNumber</span><span class="o">++</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>which actually translates (on the x86 architecture) to something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='gas'><span class='line'><span class="nf">movl</span>    <span class="p">-</span><span class="mi">12</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%eax</span>
</span><span class='line'><span class="nf">incl</span>    <span class="nv">%eax</span>
</span><span class='line'><span class="nf">movl</span>    <span class="nv">%eax</span><span class="p">,</span> <span class="p">-</span><span class="mi">12</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>which is a load, increment, then store.  So there are actually <em>two</em> potential points that a race condition could occur &ndash; between the load and the increment, and between the increment and the save.</p>

<p>Now imagine two threads, which are both using a shared object.  If both threads happen to call the method that performs the increment method at the same time, one thread could be preempted in the middle, such that the instructions are interleaved.  So for threads A and B incrementing the sequence number, thus:</p>

<table width="100%">
  <thead>
    <th>Thread</th>
    <th>Instruction</th>
    <th>m_SequenceNumber</th>
    <th>Register</th>
  </thead>
  <tbody>
    <tr><td>A</td><td><tt>LOAD m_SequenceNumber, R0</tt></td><td>234</td><td>234</td></tr>
    <tr><td>A</td><td><tt>INCR R0</tt></td><td> 234 </td><td> 235</td></tr>
    <tr><td>B</td><td><tt>LOAD m_SequenceNumber, R1</tt></td><td>234</td><td>234</td></tr>
    <tr><td>B</td><td><tt>INCR R1</tt></td><td> 234 </td><td> 235</td></tr>
    <tr><td>B</td><td><tt>STORE R1, m_SequenceNumber</tt></td><td>235</td><td>235</td></tr>
    <tr><td>A</td><td><tt>STORE R0, m_SequenceNumber</tt></td><td>235</td><td>235</td></tr>
  </tbody>
</table>


<p>So, instead of the sequence number being incremented twice, and being 236 as we would expect, the sequence number is only 235.  This is a subtle, nasty and rare bug and could be very difficult to track down for the unprepared.</p>

<p>Fortunately, there is a nice, simple solution to this particular problem.  Operating systems provide atomic functions for safely performing an increment (with a minimum of overhead), as well as a few other common operations.  Under Windows, you would use the <a href="http://msdn.microsoft.com/en-us/library/ms683614(VS.85).aspx">InterlockedIncrement()</a>, while under Mac OS X you would call <a href="http://developer.apple.com/mac/library/DOCUMENTATION/Darwin/Reference/ManPages/man3/OSAtomicIncrement32.3.html">OSAtomicIncrement32()</a>.  Under Linux, gcc provides <a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">__sync_fetch_and_add()</a> and friends.</p>

<h3>Example: Accessing a Queue</h3>

<p>An illustration of a race condition is where multiple threads are removing work items from a queue.  Imagine some code that looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">unsafeWorkerThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span> <span class="n">unsafeWorkerThreadRunning</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Warning: this is not thread-safe!</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">work_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>            <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is not thread-safe!  Even if we assume that the queue operations themselves are atomic (which is usually <em>not</em> the case for most container classes!), there is a race condition waiting to trigger a failure.  Can you spot it?</p>

<p>Imagine there are two threads running, and there is one work item in the queue.  When <code>thread_A</code> calls <code>queue.isEmpty()</code>, it goes into the <code>if</code> block, as there is more data to process.  But then the thread is pre-empted, and <code>thread_B</code> gets a chance to run.  This time, it removes the work item and processes it.  But now the queue is empty, and <code>thread_A</code> thinks it isn&rsquo;t!  When <code>thread_A</code> resumes, it will call <code>queue.pop()</code> and trigger a stack underflow exception.  (And here, without a <code>try-catch</code> block, an exception would also cause the thread to exit without notice.) Now this code could run perfectly well for thousands of iterations, and never trigger these particular failure conditions.  But every so often, the timing will be just right (or rather wrong!) and your application will mysteriously fail.  You can see why many people say threading should be avoided at all costs!  The code is valid, usually works but every so often it fails in an unusual way.</p>

<p>The simplest solution is to protect the queue with a mutex, and lock it around the inner block.  (There&rsquo;s another improvement we can make after we discuss exceptions.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">workerThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span> <span class="n">workerThreadRunning</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">queueMutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">work_t</span> <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>            <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">queueMutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(There are more esoteric solutions to this problem, such as lock-free data structures, but those are beyond the scope of this series.)</p>

<h2>Problem: Deadlocks</h2>

<p>In a non-trivial application, there may be several threads and numerous mutexes.  When more than one thread locks more than one mutex, there arises the potential for a condition known as a <em>deadlock</em>.  This is where one thread is holding a lock while waiting for another to become available, while a second thread is holding the second lock and waiting for the first lock to become available.  Since they are both waiting for each other to finish, neither can run.  This deadlocked situation can be more involved, whereby several threads form a ring of holding and waiting for locks.  This is illustrated as follows, first in code then as a diagram:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">threadA</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">mutexOne</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexTwo</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">processStuff</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexOne</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexTwo</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">void</span> <span class="n">threadB</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">mutexTwo</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexOne</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">processStuff</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexTwo</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>        <span class="n">mutexOne</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://antonym.org//img/DeadlockAnimation.gif"></p>

<p>Fortunately, the problem of deadlocks can largely be avoided by consistently locking mutexes in the same order, and unlocking them in reverse order.</p>

<h2>Problem: Exceptions</h2>

<p>Exceptions in C++ can be a very effective mechanism for error handling.  However, like many C++ features, care must be taken, especially in threads.  Because a thread is destroyed when the thread function returns, an uncaught exception can cause the entire thread to exit, without warning or notice.  So if you have a thread that mysteriously disappears, an uncaught exception is a likely culprit.</p>

<p>As with non-threaded code, you should always catch the most specific exception type that you are able to handle.  But if you wish to avoid your thread being killed, you should add a top-level <code>try-catch</code> block.  At this point, depending on the application, you may simply log the uncaught exception then exit, or you may resume thread processing (but only if safe to do so!).</p>

<p>A skeleton thread function might look something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">processThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">keepProcessing</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">try</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Do actual work</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// Catch more specific exceptions first if you can</span>
</span><span class='line'>        <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">exc</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">log</span><span class="p">(</span><span class="s">&quot;Uncaught exception: &quot;</span> <span class="o">+</span> <span class="n">exc</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
</span><span class='line'>            <span class="c1">// Maybe return here?</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Just as an errant exception can cause havoc with threads running, they can also cause problems with mutexes.  The next article shows how to use a <em>lock guard</em> to ensure mutexes are unlocked, even if an exception is thrown.</p>

<h2>Other Problems</h2>

<p>Just to reinforce the idea that multithreaded programming is not a trivial undertaking, there are even more traps for the unwary, for which there is not sufficient time to delve into here.  Issues such as <a href="http://en.wikipedia.org/wiki/Resource_starvation">starvation</a>, <a href="http://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>, and high scheduling latency are all considerations for <a href="http://en.wikipedia.org/wiki/Concurrent_programming">concurrent programming</a>.  It is definitely worth consulting a good book or three.</p>

<h2>Closing thoughts</h2>

<p>Fortunately, there are well-known solutions to multi-threaded design issues, so it is entirely possible to write robust threaded code, provided one is careful and thoughtful.  Much of it starts with:</p>

<ul>
<li><strong>Minimise shared state</strong></li>
</ul>


<p>In days gone by, a multi-threaded system would often still only be running on a single core.  Certain classes of concurrency bugs were far less likely to happen.  But now multicore systems are standard, and we have truly concurrent execution, which brings into the fray problems such as memory consistency, cache latency, write-throughs, and so on.</p>

<p>Especially now that multicore systems are shipping as standard on desktops and laptops, concurrent programming is required to take advantage of the available processing resources.  So a thorough understanding of multithreading is increasingly important.</p>

<p>Some takeaway points to remember:</p>

<ul>
<li>Minimise shared state</li>
<li>Program defensively</li>
<li>Assume your threading code can be preempted at <em>any</em> time</li>
<li>Identify shared resources and protect them with mutexes</li>
<li>Identify algorithms that need to be atomic</li>
<li>Identify code with dependent results that needs to be atomic</li>
<li>Minimise the number of resources shared between threads</li>
<li>Minimise the duration of locks</li>
<li>Ensure exceptions cannot disrupt synchronisation flow</li>
<li>Always acquire and release mutexes in the same order</li>
</ul>


<p>The next article looks at the types of mutexes, and how to use them.</p>

<h2>Archived Comments</h2>

<p>AUTHOR: Peter Sivak
DATE: 01/24/2010 09:42:21 AM
Great article!</p>

<p>I have just started learning Boost-Threads and this article very clearly explains the use of multithreading features in Boost.</p>

<p>I am giving this post a &ldquo;5-star rating&rdquo; and looking forward to the next article about &ldquo;mutexes&rdquo;.</p>

<p>Keep on.</p>

<p>COMMENT:
AUTHOR: lacau
DATE: 01/27/2010 09:23:36 PM
Nice one, keep up teaching mate ;)
Thumbs up!</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[STL: filtering]]></title>
    <link href="http://antonym.org//2009/09/stl-filtering.html"/>
    
    <updated>2009-09-16T11:51:00+10:00</updated>
    <id>http://antonym.org//2009/09/stl-filtering</id>
    
    <content type="html"><![CDATA[<p>The STL makes it easy to create lists, iterate over lists, and apply a function to each member of a list.  So how do you filter a vector according to some criteria?  It&rsquo;s not hard, but the obvious solution isn&rsquo;t <em>quite</em> enough.  Here&rsquo;s how.</p>

<!--more-->


<p>Say you have a vector of values, and you want to apply a filter to the list.  That is,  remove elements that satisfy some criteria.  It&rsquo;s quite a common requirement, so you&rsquo;d think there would be an obvious and simple way to do it.  If you go searching for the word &ldquo;filter&rdquo; in the STL documentation, you may not find much relevant in the <code>std::vector</code> method reference.  If you browse around in STL algorithms, eventually you&rsquo;ll come across a method called <code>remove_if</code>.  It takes two iterators to specify the range (first and last) of the operation, and a predicate function.  Sounds perfect!</p>

<p>Let&rsquo;s use it to filter a list of numbers, removing even numbers.  Given the following input:</p>

<pre><code>1 2 3 4 5 6 7 8 9
</code></pre>

<p>we expect to see the result:</p>

<pre><code>1 3 5 7 9
</code></pre>

<p>A predicate function is essentially a test for a property, and returns whether or not the parameter has this property.  So our predicate function will take an integer value (matching the element type of our vector) and return a boolean, denoting whether or not to remove the given element.  So we&rsquo;d have:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">bool</span> <span class="n">is_even</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Easy!  Now, to store our numbers, we would start with a simple vector of integers, thus:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vector_t</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector_t</span>    <span class="n">numbers</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>We read in the numbers in a loop and save them in the array:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">good</span><span class="p">())</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will take care of reading in the data, as it will stop as soon as it reads something that isn&rsquo;t an integer, or reaches the end of file.  Now we just apply the filter, and then print the result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">remove_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_even</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">vector_t</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There, we&rsquo;re done!  Now, we just run the completed program, and give it some test data:</p>

<pre><code>$ ./filter 
1 2 3 4 5 6 7 8 9 -
</code></pre>

<p>But wait, the output we see is wrong!</p>

<pre><code>1
3
5
7
9
6
7
8
9
</code></pre>

<p>Oh, no!  There must be a bug in the libraries!  Curses, foiled again!</p>

<p>Actually, no &ndash; the sky isn&rsquo;t falling, and there is no bug.  Now is when we probably should be doing a bit of RTFMing.  Let&rsquo;s check the docs and see what&rsquo;s going on.  According to the <a href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/">g++ library documentation</a>:</p>

<blockquote><p>&ldquo;Elements between the end of the resulting sequence and &lsquo;last&rsquo; are still present, but their value is unspecified.&rdquo;</p></blockquote>

<p>Er, ok&hellip; that&rsquo;s handy &ndash; not.  Looking back at the output, we do notice that the first 5 values are correct, but there&rsquo;s some junk after them.  And sure enough, that&rsquo;s the documented behaviour &ndash; we are just seeing the &ldquo;unspecified&rdquo; values left behind.</p>

<p>It is worth pointing out right about now that the fine folk who designed the STL were fairly obsessed with efficiency, and the STL is designed to be low-level, powerful and fast, sometimes at the expense of user friendliness.  It is more efficient to implement filtering as a generic algorithm that can be applied to any container.  And sure enough, that is the intent, as we see in the docs:</p>

<blockquote><p>&ldquo;@return   An iterator designating the end of the resulting sequence.&rdquo;</p></blockquote>

<p>Ah, we were actually supposed to do something with the return value!  The implementation of <code>remove_if</code> moves (or actually copies) the values to be kept to the head of the list, and returns an iterator pointing to the start of the &ldquo;junk&rdquo; (just after the filtered list), in preparation for this tail to be snipped off.  So, let&rsquo;s use the <code>erase</code> method to do just that:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_even</span><span class="p">),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, running the test application again, we get the output:</p>

<pre><code>1
3
5
7
9
</code></pre>

<p>Huzzah!  It is really a matter of getting a feel for the design patterns behind the STL, and the very low-level API that it provides.</p>

<p>This process can be visualised thus:</p>

<p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="STL Filtering Example" src="http://antonym.org/images/STLFilteringExample.png" width="532" height="670" class="mt-image-none" style="" /></span></p>

<p>It is also worth mentioning at this point that if you are doing a lot of adding and removing of  elements, a <code>std::list</code> is probably a better choice, as inserting and deleting elements in vectors is very expensive.</p>

<p>Now, you&rsquo;re probably wondering why <code>remove_if</code> is a function in the STL <code>algorithms</code> collection, rather than a method in <code>std::vector</code> itself.  Well, the folks who designed the STL are very, very clever.  The obvious thing would be to put a <code>remove_if</code> method in every single container class.  But the implementation would be <em>almost</em> the same, right?  Well, they reasoned, what if all container classes provided a common, minimal interface, we could implement <code>remove_if</code> just once, and it could apply to almost any container!  It&rsquo;s even more generic that way.  So there are a whole series of algorithms that apply to a wide variety of different containers, and use informal interfaces to decouple things.</p>

<p>The (platform-neutral) sample code is available below&hellip;</p>

<ul>
<li>Sample C++ code: <span class="mt-enclosure mt-enclosure-file" style="display: inline;"><a href="http://antonym.org/files/stl_filter.zip">stl_filter.zip</a></span> (4.5kB zip)</li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Threading with Boost - Part I: Creating Threads]]></title>
    <link href="http://antonym.org//2009/05/threading-with-boost---part-i-creating-threads.html"/>
    
    <updated>2009-05-13T22:16:00+10:00</updated>
    <id>http://antonym.org//2009/05/threading-with-boost&#8212;part-i-creating-threads</id>
    
    <content type="html"><![CDATA[<p><a href="http://www.boost.org/">Boost</a> is an incredibly powerful collection of portable class libraries for C++.  There are classes for such tasks as date/time manipulation, filesystem interfaces, networking, numerical programming, interprocess communication and <a href="http://www.boost.org/doc/libs">much more</a>.</p>

<p>The Boost documentation is substantial, but can still be daunting to new users.  So this article is the first of a series on using Boost, starting with basic threading.  It aims to provide an accessible introduction, with complete working examples.</p>

<!--more-->


<p>First, this article assumes you know about general threading concepts and the basics of how to use them on your platform.  (For a refresher, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Thread_(computer_science">Threads</a>).)  Here I focus specifically on how to use <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/thread.html">Boost threads</a> in a practical setting, starting from the basics.  I also assume you have Boost installed and ready to use (see the Boost <a href="http://www.boost.org/doc/libs/1_39_0/more/getting_started/index.html">Getting Started Guide</a> for details).</p>

<p>This article looks specifically at the different ways to <em>create</em> threads.  There are many other techniques necessary for real multi-threaded systems, such as synchronisation and mutual exclusion, which will be covered in a future article.</p>

<h2>Overview</h2>

<p>A <code>boost::thread</code> object represents a single thread of execution, as you would normally create and manage using your operating system specific interfaces.  For example: on POSIX systems, a Boost thread uses the <code>Pthreads</code> API, and on Win32 it uses the native <code>CreateThread</code> and related calls.  Because Boost abstracts away all the platform-specific code, you can easily write sophisticated and portable code that runs across all major platforms.  A thread object can be set to a special state of not-a-thread, in which case it is inactive (or hasn&rsquo;t been given a thread function to run yet).</p>

<p>A <code>boost::thread</code> object is normally constructed by passing the threading function or method it is to run.  There are actually a number of different ways to do so.  I cover the main thread creation approaches below.</p>

<h2>Code Examples</h2>

<p>All the code examples are provided in a single download below, which you can use for any purpose, no strings attached.  (The usual disclaimer is that no warranties apply!)  And just as Boost runs on many platforms (ie. Windows, Unix/Linux, Mac OS X and others) the example code should be similarly portable.</p>

<ul>
<li>Download <span class="mt-enclosure mt-enclosure-file" style="display: inline;"><a href="http://antonym.org/boost/boost_threads_eg1.zip"><code>boost_threads_eg1.zip</code></a> (4kB)</span></li>
</ul>


<p>There is a separate example program for each section below, and a common Bjam script to build them all (<code>Jamroot</code>).  <a href="http://www.boost.org/boost-build2/doc/html/index.html">Bjam</a> is the Boost build system, a very powerful (but notoriously difficult to learn, and worthy of a whole series of articles).</p>

<p>Having said that, you are certainly not obliged to use Bjam.  It is still worth knowing how to build applications manually before relying on scripts, so here is an example command line for manual compilation on my system (Mac OS X with Boost installed from MacPorts):</p>

<pre><code>g++ -I/opt/local/include -L/opt/local/lib -lboost_thread-mt -o t1 t1.cpp
</code></pre>

<p>All this does is add an include path (with the <code>-I</code> option) pointing to the root of the boost headers, add the library search path (with the <code>-L</code> option) and link in the threading library (<code>boost_thread-mt</code>).  You can use the above as the basis for writing our own Makefile if you prefer, or creating build rules in your IDE of choice.</p>

<h2>Doing &lsquo;Real&rsquo; Work</h2>

<p>And before we dive in, a quick note on doing &ldquo;real work&rdquo;&hellip; In the examples below, a simple sleep call is used to simulate performing actual work in the threads.  This is simply to avoid cluttering up the examples with code that would take some finite time to execute but would otherwise be irrelevant.</p>

<p>The simplest way to sleep for a given duration using Boost is to first create a time duration object, and then pass this to the <code>sleep</code> method of the special <code>boost::this_thread</code> class.  The <code>this_thread</code> class gives us a convenient way to refer to the currently running thread, when we otherwise may not be able to access it directly (ie. within an arbitrary function).  Here&rsquo;s how to sleep for a few seconds:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">// Three seconds of pure, hard work!</span>
</span><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">posix_time</span><span class="o">::</span><span class="n">seconds</span> <span class="n">workTime</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="n">boost</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">workTime</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the <code>main()</code> function, we then wait for the worker thread to complete using the <code>join()</code> method.  This will cause the main thread to sleep until the worker thread completes (successfully or otherwise).</p>

<p>The observant reader will wonder then what the advantage is in spawning a thread, only to wait for it to complete?  Surely that serialises the execution path and places us firmly back in sequential world?  What is the point of spawning a thread?  Well, until we figure out how to use the synchronisation mechanisms, this is the most straightforward approach to illustrate thread creation.  And knowing ow to &lsquo;join&rsquo; threads is also very important.  To synchronise the completion of a thread, we wait for it to finish by calling <code>workerThread.join()</code>.</p>

<p>The general structure of the examples below is shown in the following sequence diagram:</p>

<p><img src="http://antonym.org//img/BoostThreadExample.png"></p>

<p>The application starts, and the main thread runs at (a).  Then at (b), the main thread spawns the worker thread by constructing a thread object with the worker function.  Right after, at &copy;, the main thread calls <code>join</code> on the thread, which means it will go to sleep (and not consume any CPU time) until the worker thread has completed.  As soon as the worker thread is created at (b), it will start execution.  At some point later at (d), the worker completes.  Since the main thread was joining on its completion, main wakes up and continues running.  It finishes at (e) and the process terminates.  Each of the examples below follow this general scheme &ndash; the difference lies in how the threads are created.</p>

<h2>Type 1: A Thread Function</h2>

<p>The simplest threading scenario is where you have a simple (C-style) function that you want to run as a separate thread.  You just pass the function to the <code>boost::thread</code> constructor, and it will start running.  You can then wait for the thread to complete by calling <code>join()</code>, as shown above.</p>

<p>The following example shows how.  First, we include the correct Boost thread header, create the thread object and pass in our worker function.  The main thread in the process will then wait for the thread to complete.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/thread.hpp&gt;</span>
</span><span class='line'><span class="cp">#include &lt;boost/date_time.hpp&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">workerFunc</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">posix_time</span><span class="o">::</span><span class="n">seconds</span> <span class="n">workTime</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Worker: running&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Pretend to do something useful...</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">workTime</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Worker: finished&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: startup&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workerThread</span><span class="p">(</span><span class="n">workerFunc</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: waiting for thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">workerThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: done&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When you run the program, you should see output similar to the following:</p>

<pre><code>% ./t1
main: startup
main: waiting for thread
Worker: running
Worker: finished
main: done
</code></pre>

<p>It&rsquo;s as simple as that!  This created a thread and ran it, and you would have seen a pause while the worker thread was running (ok, busy sleeping!).  Later on, we&rsquo;ll do something a bit more substantial.  But this example shows the absolute minimum code required to start a simple thread.  Simply pass your function to the <code>boost::thread</code> constructor.</p>

<h2>Type 2: Function with Arguments</h2>

<p>So the above function wasn&rsquo;t terribly useful by itself.  We really want to be able to pass in arguments to the thread function.  And fortunately, it&rsquo;s very easy &ndash; you simply add parameters to the thread object&rsquo;s constructor, and those arguments are automagically bound and passed in to the thread function.</p>

<p>Let&rsquo;s say your thread function had the following signature:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">workerFunc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">delaySecs</span><span class="p">)</span> <span class="c1">//...</span>
</span></code></pre></td></tr></table></div></figure>


<p>You simply pass the arguments to the thread constructor after the name of the thread function, thus:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workerThread</span><span class="p">(</span><span class="n">workerFunc</span><span class="p">,</span> <span class="s">&quot;Hello, boost!&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>This example is called &lsquo;t2&rsquo; in the source examples.</p>

<h2>Type 3: Functor</h2>

<p>A functor is a fancy name for an object that can be called just like a function.  The class defines a special method by overloading the <code>operator()</code> which will be invoked when the functor is called.  In this way, the functor can encapsulate the thread&rsquo;s context and still behave like a thread function.  (Functors are not specific to threads, they are simply very convenient.)</p>

<p>This is what our functor looks like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Worker</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Worker</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span> <span class="n">guess</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">iter</span><span class="p">)</span>
</span><span class='line'>            <span class="o">:</span> <span class="n">m_Number</span><span class="p">(</span><span class="n">N</span><span class="p">),</span>
</span><span class='line'>              <span class="n">m_Guess</span><span class="p">(</span><span class="n">guess</span><span class="p">),</span>
</span><span class='line'>              <span class="n">m_Iterations</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Worker: calculating sqrt(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m_Number</span>
</span><span class='line'>                  <span class="o">&lt;&lt;</span> <span class="s">&quot;), itertations = &quot;</span>
</span><span class='line'>                  <span class="o">&lt;&lt;</span> <span class="n">m_Iterations</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Use Newton&#39;s Method</span>
</span><span class='line'>        <span class="kt">float</span>   <span class="n">x</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">float</span>   <span class="n">x_last</span> <span class="o">=</span> <span class="n">m_Guess</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_Iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">x</span> <span class="o">=</span> <span class="n">x_last</span> <span class="o">-</span> <span class="p">(</span><span class="n">x_last</span><span class="o">*</span><span class="n">x_last</span><span class="err">\</span><span class="o">-</span><span class="n">m_Number</span><span class="p">)</span><span class="o">/</span>
</span><span class='line'>                    <span class="p">(</span><span class="mi">2</span><span class="err">\</span><span class="o">*</span><span class="n">x_last</span><span class="p">);</span>
</span><span class='line'>            <span class="n">x_last</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Iter &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; = &quot;</span>
</span><span class='line'>                  <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Worker: Answer = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">unsigned</span>    <span class="n">m_Number</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">float</span>       <span class="n">m_Guess</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span>    <span class="n">m_Iterations</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>This worker functor calculates a square root of a number using <a href="http://en.wikipedia.org/wiki/Newton%27s_method">Newton-Rhapson&rsquo;s method</a>, just for fun (ok, I got bored putting sleep in all the threads).  The number, a rough guess and the number of iterations is passed to the constructor.  The calculation (which is in fact extremely fast) is performed in the thread itself, when the <code>operator()()</code> gets called.</p>

<p>So in the main code, first we create our callable object, constructing it with any necessary arguments as normal.  Then you pass the instance to the <code>boost::thread</code> constructor, which will invoke the <code>operator()()</code> method on your functor.  This becomes the new thread, and runs just like any other thread, with the added benefit that it has access to the object&rsquo;s context and other methods.  This approach has the benefit of wrapping up a thread into a convenient bundle.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: startup&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Worker</span> <span class="n">w</span><span class="p">(</span><span class="mi">612</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workerThread</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: waiting for thread&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">workerThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;main: done&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note: A very important consideration when using functors with boost threads is that the thread constructor takes the functor parameter <em>by value</em>, and thus makes a <em>copy</em> of the functor object.  Depending on the design of your functor object, this may have unintended side-effects.  Take care when writing functor objects to ensure that they can be safely copied.</p>

<h2>Type 4: Object method I</h2>

<p>It is frequently convenient to define an object with an instance method that runs on its own thread.  After all, we&rsquo;re coding C++ here, not C!  With Boost&rsquo;s <code>thread</code> object, this only slightly more work than making a regular function into a thread.  First, we have to specify the method using its class qualifier, as you would expect, and we use the <code>&amp;</code> operator to pass the address of the method.</p>

<p>Because methods in C++ always have an implicit <code>this</code> pointer passed in as the first parameter, we need to make sure we call the object&rsquo;s method using the same convention.  So we will pass the object pointer (or <code>this</code> depending on whether we are inside the object or not) as the first parameter, along with any other actual parameters we might have after that, thus:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Worker</span> <span class="n">w</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workerThread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Worker</span><span class="o">::</span><span class="n">processQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>As an aside, take care in your own code that you don&rsquo;t accidentally allocate an object on the stack in one place, spawn a thread, then have the object go out of scope and be destroyed before the thread has completed!  This could be the source of many tricky bugs.</p>

<p>The full listing is essentially the same.  To pass additional parameters to the method, simply add them in the constructor to the thread object after the object pointer.</p>

<h2>Type 5: Object method II</h2>

<p>You may want to create a bunch of objects that manage their own threads, and can be created and run in a more flexible manner than keeping around a bunch of objects along with their associated threads in the caller.  (I think they call this encapsulation.)</p>

<p>So our final example places the thread instance within the object itself, and provides methods to manage them.  Since the thread object exists as an instance member (as opposed to a pointer), what happens in the constructor?  In particular, what if we don&rsquo;t want to run the thread at the same time as we create our object?  Fortunately, the default constructor for the thread creates it in an &ldquo;invalid&rdquo; state, called <code>not-a-thread</code>, which will do nothing until you assign a real one to it (in our <code>start</code> method, for example).</p>

<p>So now our class declaration has the following data member added:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span>    <span class="n">m_Thread</span><span class="p">;</span>
</span><span class='line'><span class="c1">//...</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>Worker::start()</code> method spawns the thread which will run the <code>processQueue</code> method.  Notice how we pass in <code>this</code> as the first bound parameter?  Because we are using an instance method (and not a class method or regular function), we must ensure the first parameter is the instance pointer.  The <code>N</code> parameter is the first actual parameter for the thread function, as can be seen in its signature.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">start</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">m_Thread</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Worker</span><span class="o">::</span><span class="n">processQueue</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The join method is very simply:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">m_Thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>which means our main function becomes no more than:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">Worker</span> <span class="n">worker</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">worker</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">worker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>This encapsulation of the threading can be very useful, especially when combined with patterns such as the Singleton (which we will look at in a future article).</p>

<h2>Conclusion</h2>

<p>We have seen a variety of techniques for creating threads using the Boost threading library.  From simple C functions to instance methods with parameters, the thread class permits a great deal of flexibility in how you structure your application.</p>

<h2>Future Articles</h2>

<p>In later installments, we will look at synchronisation methods, mutexes, and all sorts of other interesting techniques.</p>

<p>Please leave a comment below, with any questions or feedback you may have.  Too long?  Too brief?  More details required?  Something confusing?  Let me know.</p>

<h2>Archived Comments</h2>

<p>AUTHOR: saesh
DATE: 06/10/2009 11:32:39 PM
nice article. helped me to get into thread. thank you.</p>

<p>looking forward for an article about synchronization though.</p>

<p>AUTHOR: tflmike
DATE: 06/23/2009 02:45:13 PM
A good tutorial with a clear explaination for beginning to work with boost threads, your article cleared it up for me, thank you.</p>

<p>AUTHOR: paolo
DATE: 08/01/2009 02:02:33 AM
great, thanks a lot.
it saved me one hour of hopeless searching over the internet&hellip;</p>

<p>AUTHOR: Zach
DATE: 08/08/2009 02:57:34 AM
OMG, Thank you so much for taking your time to do this. I  have learn much and take much from this please continue</p>

<p>AUTHOR: Zach
DATE: 08/08/2009 04:12:02 AM
Can you please do tutorial on multithreading with Boost C++ :)</p>

<p>AUTHOR: Leandro
DATE: 08/31/2009 03:25:08 AM
Very nice article!!! It&rsquo;s hard to find good articles like this about the Boost Thread library. Please, write about synchronization and the correlated stuffs.</p>

<p>Good work!!! Thanks!!!</p>

<p>AUTHOR: Marian
DATE: 09/04/2009 07:43:29 PM
Superb!
I&rsquo;m only beginer in c++ and this way of explanation is really useful for me.
Thank you and don&rsquo;t forget to continue :&ndash;)</p>

<p>AUTHOR: Yuriy
DATE: 09/18/2009 10:20:18 PM
Easy to understand. Very helpful! Thanks a lot!</p>

<p>AUTHOR: Raby Whyte
DATE: 09/29/2009 02:07:59 AM
Very helpful indeed. Thanks :) Keep &lsquo;em coming</p>

<p>AUTHOR: sk
DATE: 10/07/2009 02:40:56 AM
Quite good article.
Hope you can have a time for your future ones about boost thread</p>

<p>AUTHOR: murli Dhar
DATE: 10/26/2009 02:56:09 AM</p>

<p>Wow! That was a GR8 piece of article. Extremely well written. It is unbelieveable that there are people like you out there,you can put some good work out there for the community without expecting anything back.</p>

<p>Keep it up!</p>

<p>Murli</p>

<p>AUTHOR: Alan Orcharton
DATE: 10/30/2009 08:30:57 AM
Thanks &ndash; a great summary!!  to help me with everythng I needed get started using boost threads</p>

<p>AUTHOR: Cuong Bui
DATE: 04/16/2010 03:37:30 PM
Very excellent article. From this, I get more knowlegde into threading with Boost.</p>

<p>Many thanks,
Cuong Bui</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[The first user]]></title>
    <link href="http://antonym.org//2009/04/the-first-user.html"/>
    
    <updated>2009-04-30T23:26:00+10:00</updated>
    <id>http://antonym.org//2009/04/the-first-user</id>
    
    <content type="html"><![CDATA[<p>When you are developing a new piece of software, you typically first spend quite some time setting up your development environment.  As you progress, your application becomes a very cozy inhabitant of this environment, a safe happy cocoon that has evolved as you make lots of small changes to the application or your system.  What could possibly go wrong?</p>

<!--more-->


<p>Eventually you will have something to actually test, and the time comes to send your little application out into the &ldquo;Real World&rdquo;, to be tested in the some unknown, potentially harsh environment for which it may be ill prepared.</p>

<p>Your first user comes along when you run your software on any machine other than the one it was created on.  Getting your application to run on another machine is a very important milestone in the overall lifecycle, and doing it earlier rather than later can help flush out all sorts of potential problems.  (Getting it to <em>build</em> on another machine is a topic for another day.)</p>

<p>So what sort of issues do you need to consider?</p>

<h2>System Requirements</h2>

<p>What kind of hardware requirements does it have?  Does it test for system requirements on startup?  Does it produce sensible diagnostic messages if anything is lacking?  What is the working set (typical memory usage) or your application?  Can you estimate memory requirements?  What disk space, beyond the installed files, does it require?  Is it performance-sensitive, and if so, have you profiled it to determine what baseline CPU is required?  Do you require any particular drivers to be present?</p>

<h2>Packaging and Dependencies</h2>

<p>Do you need an installer program?  Can it run standalone, from a network drive, or a USB stick? What are the runtime dependencies?  In other words, which shared libraries or DLLs does it need to run?  Do you need to provide the redistributable C or C++ runtime?  What resources does it need (ie. images, sounds, help files, shaders, scripts, etc)?  What configuration settings does it require?  Does it have sensible defaults for any preferences that aren&rsquo;t set in a fresh installation?  Does it use optional features that are only available in a certain version of the OS?  Does it assume that particular files are to be found in a particular directory?  The current directory?  The same directory as the executable?  Any assumptions you make during development will surely be tested.  Just getting the application to launch, let alone run correctly, is the first hurdle.</p>

<h2>Logging</h2>

<p>You will most likely be providing a Release build to external users.  However, this typically disables any debug logging you might have placed in your code.  If anything should go wrong (against all odds!), you will really save time if you can leave logging on in a Release build, so you can get your guinea pigs to email you the output in the event of the unthinkable.</p>

<h2>Versioning</h2>

<p>Give each release a unique and easily identifiable version number.  Show it in the About box, or even in the title bar.  Embed it in the resource metadata of the executable.  Make it easy to answer the question &ldquo;which version is <em>that</em> you&rsquo;re running?&rdquo;  If it is supported, you can even add it as a suffix of the executable filename, so you can have multiple versions in the one directory, which can be quite handy.</p>

<h2>Release Notes</h2>

<p>Make sure you describe what features work, what features are missing, and what changed in the most recent release.  Don&rsquo;t forget to describe known bugs, too.  Otherwise you will be peppered with &ldquo;well X doesn&rsquo;t work!&rdquo; comments, when you know already, you&rsquo;re just not up to that bit yet!  Also provide at least a date and version number, which can be correlated with the software.  Any bugs that get filed will obviously require this information, and it helps with tagging in your version control system too.</p>

<h2>And more&hellip;</h2>

<p>As I was writing the above, it became clear that each one of these topics could become an article on its own.  Please comment below if you would like to see more detailed discussion on the above, or have some thoughts to share on the topic.</p>

<hr />

<p>EXCERPT:</p>

<hr />

<p>KEYWORDS:</p>

<hr />

<p>COMMENT:
AUTHOR: Michael Rowe
URL: <a href="http://mikerowecode.com/">http://mikerowecode.com/</a>
DATE: 05/14/2009 06:35:35 PM</p>

<pre><code>Getting your application to run on another machine is a very important milestone in the overall lifecycle, and doing it earlier rather than later can help flush out all sorts of potential problems.
</code></pre>

<p>So important, in fact, that many people nowadays use &ldquo;continuous integration&rdquo; servers to do exactly this. The idea is to have a build server that can automatically build your software and run a suite of tests, ideally every time someone commits to version control. This should be established as early as possible in the development cycle (i.e. pretty much from day one).</p>

<p>Products such as <a href="http://www.vmware.com/products/labmanager/">Lab Manager</a>, in conjunction with a build server, even allow you to build and test your software on all sorts of disparate target platforms and configurations.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Improve your C++: const-correctness]]></title>
    <link href="http://antonym.org//2008/11/improve-your-c-plus-plus-const-correctness.html"/>
    
    <updated>2008-11-22T15:18:00+11:00</updated>
    <id>http://antonym.org//2008/11/improve-your-c-plus-plus-const-correctness</id>
    
    <content type="html"><![CDATA[<p>Writing &ldquo;const-correct&rdquo; code will improve the quality and maintainability of your code.  It is especially important and useful when writing Object-Oriented code, as objects are often passed around as constant references.  Properly declaring non-mutating methods as <code>const</code> allows you to safely call any <code>const</code> method on such a reference.  It is part of good type-safe practice and good code hygiene. So how do we do it?</p>

<!--more-->


<p>First, some definitions:</p>

<ul>
<li><em>mutating</em>: any function or method that alters the state of an object (ie. makes an assignment to any of its data members) is a &lsquo;mutating&rsquo; operation. For example, calling a &ldquo;setter&rdquo; method is a mutating operation.</li>
<li><em>non-mutating</em>: any operation that does not modify the object&rsquo;s data members.  For example, calling a &ldquo;getter&rdquo; method, or performing and returning a calculation.</li>
<li><code>const</code> <em>parameter</em>: if you have a constant reference or pointer to an object, you may not modify it or call any mutating methods on it.</li>
<li><code>const</code> <em>method</em>: a method declared constant promises not to modify the object when called.</li>
<li><code>const</code> <em>correct</em>: writing code that consistently declares methods and parameters <code>const</code>, wherever possible.</li>
</ul>


<p>There are two simple rules of thumb to follow:</p>

<ol>
<li>If a method does not modify the object&rsquo;s state, the method should be declared <code>const</code>.</li>
<li>If a method or function does not modify a pointer or reference parameter, the parameter should be declared <code>const</code>.</li>
</ol>


<p>Together, these two rules ensures that objects are <code>const</code> as often as possible.  Why is this a good thing?  It gives the compiler more type information, which can catch potential bugs, and even give opportunities for optimization.</p>

<p>How do you declare a method to be <code>const</code>?  Just add the <code>const</code> keyword after the normal method declaration, thus:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="n">calculateSum</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>You declare a function or method parameter <code>const</code> in the usual way.  Note that in C++, references are usually preferred over pointers wherever possible (unless the parameter is optional, so could be <code>NULL</code>).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">unsigned</span> <span class="n">processTree</span><span class="p">(</span><span class="k">const</span> <span class="n">node</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Less Good Example</h2>

<p>Let&rsquo;s use a simple Customer class as an example.  This is valid, but not really const-correct code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Customer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>        <span class="n">Customer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span>
</span><span class='line'>            <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">_name</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>       <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aName</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">_name</span> <span class="o">=</span> <span class="n">aName</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...and elsewhere...</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="n">Invoice</span><span class="o">::</span><span class="n">addCustomer</span><span class="p">(</span><span class="n">Customer</span><span class="o">&amp;</span> <span class="n">cust</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...call any methods</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="n">Invoice</span><span class="o">::</span><span class="n">getInvoiceCountFor</span><span class="p">(</span><span class="n">Customer</span><span class="o">&amp;</span> <span class="n">cust</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...call any methods</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are several opportunities here to add <code>const</code> qualifiers to the code.  The accessor method for <code>name</code> does not modify the object state, so it can be made into a <code>const</code> method by adding the keyword at the end of the method signature.  The initial value for <code>name</code> in the constructor, along with the new name in the mutator can both take <code>const</code> references to strings (instead of passing by-value, which is less efficient).</p>

<h2>Improved Example</h2>

<p>So the above code becomes:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Customer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>        <span class="n">Customer</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span>
</span><span class='line'>            <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">_name</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>       <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">aName</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">_name</span> <span class="o">=</span> <span class="n">aName</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ...and elsewhere...</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="n">Invoice</span><span class="o">::</span><span class="n">addCustomer</span><span class="p">(</span><span class="k">const</span> <span class="n">Customer</span><span class="o">&amp;</span> <span class="n">cust</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...call any const methods</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="n">Invoice</span><span class="o">::</span><span class="n">getInvoiceCountFor</span><span class="p">(</span><span class="k">const</span> <span class="n">Customer</span><span class="o">&amp;</span> <span class="n">cust</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...call any const methods</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Once you have a <code>const</code> reference to an object (such as the <code>cust</code> parameter above in <code>getInvoiceCountFor()</code>, you can only call <code>const</code> methods on that object.  For example, the compiler will flag it as an error if you try to call <code>setName()</code>, as it is a mutating method.</p>

<h2>Advantages</h2>

<p>So why go to the extra effort?  Doesn&rsquo;t it mean you can do <em>less</em> with the objects if you go around declaring things <code>const</code>?  Potentially, yes.  But there are a number of benefits:</p>

<ul>
<li>giving the compiler more type information can help catch potential bugs</li>
<li>establishes a &ldquo;contract&rdquo;, so you know that certain methods or functions will not modify your objects</li>
<li>acts as a form of documentation, by declaring the behaviour of methods and treatment of parameters</li>
<li>provides opportunities for optimization by the compiler</li>
</ul>


<h2>Summary</h2>

<p>By following the two simple rules above, you can write tighter, safer code that is easier to manage.</p>

<h2>Archived Comments</h2>

<p>Author: ChuckD
Date: 07/09/2009 03:26:30 PM</p>

<p>Thanks!  Well written and very helpful.</p>
]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[STL Iterators and Performance]]></title>
    <link href="http://antonym.org//2008/05/stl-iterators-and-performance.html"/>
    
    <updated>2008-05-30T11:02:00+10:00</updated>
    <id>http://antonym.org//2008/05/stl-iterators-and-performance</id>
    
    <content type="html"><![CDATA[<p>The Standard Template Library (STL) for C++ provides a set of powerful and flexible templated container classes.  Never again will you have to hand-craft a doubly-linked list (and get your pointer arithmetic mixed up) &mdash; just use <code>std::list&lt;T&gt;</code>.</p>

<p>Now most of the idiomatic C++ code I&rsquo;ve read that uses STL iterators uses the prefix <code>operator++</code> to move the iterator forward.  And so I had long ago adopted this too, with a vague recollection of having read somewhere that it performed better.  But why?  Good question&hellip;</p>

<!--more-->


<p>The use of the post-increment operator is well established idiomatic code for looping (in both C and C++):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">for</span> <span class="p">(</span> <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something with array[i]</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When the indexing variable is an ordinal type (usually an integer), the incrementing order makes no difference.  The expressions <code>++i</code> and <code>i++</code> are identical in this case.  And so many people developing in C++ simply use the same style in C++ with their iterator code.  Why would it matter?</p>

<p>Well, it turns out that it does.  If the indexing variable is a class, such as an iterator, there are some subtle differences between the pre-increment and post-increment operators that may have a big impact on performance.</p>

<p>Referring back to Scott Meyer&rsquo;s wonderful <a href="http://www.amazon.com/More-Effective-C%2B%2B-Addison-Wesley-Professional/dp/020163371X/ref=pd_bbs_sr_1/002-4241626-5806441?ie=UTF8&amp;s=books&amp;qid=1190249817&amp;sr=8-1">More Effective C++</a> book, I tracked down the explanation (item 6, page 31), which I will attempt to reproduce here in simplified form.  The signature of the pre-increment <code>operator++</code> for a class T is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span> <span class="c1">// prefix</span>
</span></code></pre></td></tr></table></div></figure>


<p>while the post-increment operator had a dummy parameter added to make the signature unique:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">const</span> <span class="n">T</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span> <span class="kt">int</span> <span class="p">);</span> <span class="c1">// postfix</span>
</span></code></pre></td></tr></table></div></figure>


<p>But that isn&rsquo;t the only difference &ndash; notice that the prefix operator returns a <em>reference</em> to the object itself (permitting chaining of method calls), while the postfix operator returns a <em>const object</em>, semantically defined as the previous value.  (This is for consistency with the behaviour of ordinal types.)</p>

<p>The result is that the pre-increment operator modifies the object in-place, whereas the post-increment operator will result in temporaries being created, invoking the constructor and destructor.  So something as simple as <code>++it</code> versus <code>it++</code> turns out to have some significant side-effects when applied to an object with overloaded operators.  Since this is the case with virtually all iterators in the STL, as well as many other similar objects, it is worth investigating.</p>

<p>So I decided to quantify the difference, to see how much of a difference it made.  I wrote a test program that created a very large (5 million) array of integers, and iterated over the array.  I used a high-resolution timer to time two versions of the loop, identical save for one being pre-increment and one being post-increment.  After a warmup of 3 runs, I ran the test 10 times, collected the timings and compared them.</p>

<p>The results were very interesting: on an Intel workstation, the pre-increment code took an average of 14.1ns per call, while the post-increment code took 27.6ns per call.  That&rsquo;s a significant difference of 49%, or nearly twice as fast!  A plot of 10 iterations each is shown below:</p>

<p><img src="http://antonym.org//img/results_ppc_g4.png"></p>

<p>So &ndash; it really can improve the performance of your code to write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">mylist</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span> <span class="n">it</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span> <span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// do something with *it</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For small arrays, it may not make much of a noticeable difference, but every cycle counts, and a little consistency goes a long way.  Using the prefix increment will enable your application to scale better.</p>

<p>Using the prefix form won&rsquo;t make your actual loop run twice as fast, as the iterator increment is only one component contributing to the performance, and the looping overhead may indeed be swamped by the execution time of the body.  So as always, YMMV!</p>

<p>I have provided the test source in C++, along with an R script to summarise and plot the output.  You can download it via the attachment linked at the end of this article.  The code should compile on any POSIX-conforming system with a decent C++ compiler.  And if you do your own performance tests, please drop me a line and let me know what you found.</p>

<p>As one final note, the wonderful <a href="http://www.boost.org/">Boost++ library</a> provides the <code>foreach</code> module, which provides a powerful wrapper to iterate over containers with a nice clean simple syntax:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">foreach</span><span class="p">(</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">numbers</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And yes, it uses the pre-increment operator for maximum performance.</p>

<p>The source used for this article:</p>

<ul>
<li><a href="http://www.github.com/gavinb/iterperf/">iterperf source on GitHub</a></li>
</ul>

]]></content>
    
  </entry>
  
  <entry>
    
    <title type="html"><![CDATA[Debugging NSBezierPath drawing]]></title>
    <link href="http://antonym.org//2008/02/debugging-nsbezierpath-drawing.html"/>
    
    <updated>2008-02-19T21:38:00+11:00</updated>
    <id>http://antonym.org//2008/02/debugging-nsbezierpath-drawing</id>
    
    <content type="html"><![CDATA[<p>I was working on some Cocoa programming, making heavy use of <code>NSBezierPath</code>.  I wished there was an easy way to see just where my control points were ending up, and how the curves were being constructed.  So I wrote a category method to add such a thing to the NSBezierPath class.  It is here for all to share.</p>

<!--break-->


<p>Here&rsquo;s an example of annotating a curve:</p>

<p><img src="http://img.skitch.com/20080219-cp95n9wjm391ptfarkja1hg7xf.png" alt="BezTest1"/></p>

<p>It&rsquo;s very simple, but very handy as you can easily switch from the normal stroking of the path to this annotated version in one line.  It puts blue dots on all the regular points, green dots for the control points, adds lines to join control points to their anchor point, and adds a label so you can see the direction of the control point (so &ldquo;cp3_2&rdquo; is anchored at point 3, on the side of point 2.  It also draws the bounding box in red, so you can see the extents of the full path.</p>

<ul>
<li>Grab the code (MIT license): <a href="http://antonym.org/files/antonym/bezier_debug.zip">bezier_debug.zip</a> (2kB)</li></ul></li>
</ul>


<p>Enjoy!  I&rsquo;d love to get feedback from anyone who tries this.  (Please email me; the comments system is sadly flooded with spam and I may miss legitimate posts.)</p>

<h2>Update: New project hosting</h2>

<p>Thanks to Mathieu Tozer, this little module has been incorporated into the <a href="http://code.google.com/p/morecocoa/">morecocoa</a> project, hosted at Google Project Hosting.  Please obtain the latest source from there.</p>

<ul>
<li><a href="http://code.google.com/p/morecocoa/"><a href="http://code.google.com/p/morecocoa/">http://code.google.com/p/morecocoa/</a></a></li>
</ul>

]]></content>
    
  </entry>
  
</feed>
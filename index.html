
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>antonym.org</title>
  <meta name="author" content="Gavin Baker">

  
  <meta name="description" content="The humble for loop is one of the oldest control flow control constructs
in the Algol-family of languages. Yet while other languages have extended &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://antonym.org//index.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="antonym.org" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!-- before custom head -->
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
<link rel="openid.server" href="https://indieauth.com/openid" />
<link rel="openid.delegate" href="http://gavinb.antonym.org/" />

  <!-- after custom head -->
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-6131956-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><h1>antonym.org</h1>
<h2>Bits by Gavin Baker</h2>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:antonym.org/" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2014/02/c-plus-plus-11-range-based-for-loops.html">C++11 Range-based for Loops</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-25T08:44:00+11:00" pubdate data-updated="true">2014-02-25</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The humble <code>for</code> loop is one of the oldest control flow control constructs
in the Algol-family of languages.  Yet while other languages have extended
their syntax to allow <code>for</code> loops to do all sorts of crazy and useful things
beyond iterate over a range of numbers, C and C++ have remained steadfast &ndash;
until now.</p>

<p>The <code>for</code> loop finally has a new syntax to better support iterators and
ranges (a great new feature in C++11/14).  So you can now iterate over much
more than just numbers.</p>

<p>The C++ container classes provide iterators, but the looping syntax is
rather unweildly but familiar pattern:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iter</span> <span class="n">it</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For some time, the most excellent <a href="http://www.boost.org/">Boost++ project</a>
has provided some syntactic sugar to reduce the complexity of this code
considerably.  By using Boost&rsquo;s <code>foreach</code> library, you can replace the above
loop with the much simpler:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;boost/foreach.hpp&gt;</span>
</span><span class='line'><span class="cp">#define foreach BOOST_FOREACH</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">foreach</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But now the C++11 specification has this style of syntax (with a slight
change of punctuation; it uses &lsquo;:&rsquo; rather than &lsquo;,&rsquo;). So now you can write:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is obviously much cleaner and clearer than the iterator-based code.  If
all you need to do is iterate over a container, you can start using this
syntax straight away.</p>

<p>(Aside: if you are actually going to sum the contents of a vector, using the
<code>reduce</code> algorithm is even better.)</p>

<h2>Ranges</h2>

<p>The iterators in the STL have <code>begin()</code> and <code>end()</code> methods to control
iteration loops.  New in C++11 are <code>begin()</code> and <code>end()</code> <em>functions</em>, which
can be used to construct ranges.  So what is a range?</p>

<h2>The new <code>for</code> loop in detail</h2>

<p>So how does this new <code>for</code> loop actually work?</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2014/02/c-plus-plus-11-futures.html">C++11 Futures</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-25T08:44:00+11:00" pubdate data-updated="true">2014-02-25</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Concurrency is one of the most significant challenges facing software
development today.  As the gains in processor performance diminish year over
year, additional cores have become the norm.  For some years now, multicore
processors have become the norm.</p>

<p>Taking advantage of multiple cores has usually required writing multithreaded
code, which can be complex to design and debug.  One of my favourite new
features in the C++11 standard library is the <code>future</code> module.  This provides
an extra layer of abstraction over threads, providing a simple mechanism
for asynchronous (ie. concurrent) processing.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2014/02/c-plus-plus-11-futures.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2014/02/c-plus-plus-11-shared-pointer.html">C++11 Smart Pointers: Shared Pointer</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-02-13T18:45:00+11:00" pubdate data-updated="true">2014-02-13</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In the last article on smart pointers, we looked at <code>std::unique_ptr</code>, which
provides a simple and safe smart pointer to wrap heap allocations.  As the name
implies, this smart pointer type cannot be shared between multiple threads.</p>

<p>So then how can you ensure that the memory is freed once all referring threads
have finished with the resource?  This is especially difficult when the thread
lifecycle is non-deterministic.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2014/02/c-plus-plus-11-shared-pointer.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2014/01/c-plus-plus-11-unique-pointer.html">C++11 Smart Pointers: Unique Pointer</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2014-01-31T18:29:00+11:00" pubdate data-updated="true">2014-01-31</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>C++11 introduces many significant improvements to the language and runtime. One
of the most important is to do with memory management &ndash; specifically, smart
pointers.  The <code>unique_ptr</code> makes managing dynamically allocated memory safe and
simple.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2014/01/c-plus-plus-11-unique-pointer.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2013/10/what-is-rust.html">What Is Rust?</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2013-10-08T20:50:00+11:00" pubdate data-updated="true">2013-10-08</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.rust-lang.org/">Rust</a> is a compiled, hybrid imperative/object-
oriented/functional language. It appeals directly to any C++ developer who has
battled with memory management, and Python developers who long for faster code.
So why might you be interested in learning Rust?</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2013/10/what-is-rust.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2012/02/threading-with-boost---part-iv-mutex-examples.html">Threading With Boost - Part IV: Mutex Examples</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2012-02-22T00:00:00+11:00" pubdate data-updated="true">2012-02-22</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This article continues the series on threading with Boost, by looking in
depth at several different example programs which illustrate different
aspects of using mutexes.  We look at the code, and discuss how it is
implemented.</p>

<h1>Mutex Examples</h1>

<p>The full source for the sample applications is provided below.  It is
designed to be fully portable, and has been tested on Mac OS X and Linux.
It should work fine on Windows (please send a patch if it doesn&rsquo;t!).</p>

<p>You can browse all the sources in the <a href="http://bitbucket.org/gavinb/boost_samples">Boost Samples repository</a>
for the latest, or use <a href="http://www.selenic.com/mercurial/">Mercurial</a>
to clone your own copy with this shell command:</p>

<pre><code>hg clone http://hg.antonym.org/src/boost_mutex
</code></pre>

<p>Running <code>bjam</code> or <code>make</code> will build all the examples for you, which you can
run from the appropriate subdirectory (depending on your toolchain and
architecture).</p>

<h1>Duelling Threads</h1>

<p>Source module: <code>duel.cpp</code></p>

<p>This example shows how threads are sensitive to timing and scheduling.
There is a global counter which starts at 0.  Two threads are created which
both try to modify the same counter; one incrementing and the other
decrementing.  The program runs for a fixed time, then the counter is
printed.</p>

<p>What would you expect to happen?  (It is worth thinking about this before
reading on&hellip;!)  Assuming the threads get equal time to run, you would think
that their effects would cancel each other out &ndash; that the same number of
increments and decrements would occur, and the result would be 0, or at
least very close to 0. Right?</p>

<p>Here&rsquo;s the result of running the test 10 times for 5 seconds each:</p>

<pre><code>Final counter = -1
Final counter = -3
Final counter = 1
Final counter = -1
Final counter = 0
Final counter = 3
Final counter = -57
Final counter = -8
Final counter = 7
Final counter = -5
</code></pre>

<p>Often the result is quite close to zero, but there are several runs which
are significantly above or below 0. And there&rsquo;s one huge outlier where one
of the counter threads (quiz: which one?) was starved of some time while the
other kept working (answer: the incrementing thread, since the counter is
negative, indicating that the decrementing thread was scheduled for longer).</p>

<p>So even on a machine with very few other processes running, even small
variations in timing and scheduling can lead to a significant variation in
the result.</p>

<p>The moral of this story: <em>the interaction between threads is time-sensitive
and non-deterministic</em> (in the absence of synchronisation).</p>

<h1>Trylock with Queueing Threads</h1>

<p>Source module: <code>trylock.cpp</code></p>

<p>This sample illustrates two cooperating threads: a <em>producer</em> which places
work items in a queue, and a <em>consumer</em> which removes work items from the
queue.  The shared queue is protected by a mutex.</p>

<p>Each thread locks the mutex when pushing or pulling work items, to protect
against concurrent access.  Work items are arbitrarily represented by random
numbers.  Each thread holds the lock for a random time delay to simulate
processing.</p>

<p>Since the producer may be holding the lock when the consumer wants to access
the queue (or vice versa), the consumer performs a <code>try_lock</code> on the mutex.
So instead of blocking until the mutex is free (as a regular call to
<code>lock()</code> would), the call fails immediately if the mutex is already locked,
and the thread resumes.  This contention is reported separately, as it is
import</p>

<p>Each thread prints out the stage it is executing, to enable analysis of the
interaction.</p>

<p>Note that this technique is <strong>not</strong> a good model for real world use &ndash; it is
specifically designed to illustrate one aspect of using mutexes.  For a much
better implementation of the Producer-Consumer pattern, see the article on
Boost Condition variables later in this series.</p>

<p>Takehome message: <em>thread contention for shared resources wastes processor
cycles and can erase performance improvements gained from concurrent code</em>.</p>

<h1>Mutex Locking with Timeout</h1>

<p>Source module: <code>timedlock.cpp</code></p>

<p>Shows how to use <code>try_lock</code> on a mutex.  A &lsquo;holding&rsquo; thread idles for a
short time, then grabs the mutex and holds it for another short time before
unlocking it.  The second thread is the &lsquo;trying&rsquo; thread, in that it idles
and then <em>tries</em> to acquire a lock on the mutex.  But it specifies a timeout
by calling the <code>timed_lock()</code> method, and can fail if the holding thread
hasn&rsquo;t released the mutex in time.  If it manages to grab the mutex, it
holds it for a short time also.  The idle and holding times are different,
to ensure the threads don&rsquo;t run in lockstep.  Note that <code>unlock()</code> is only
called if the lock succeeds!</p>

<h1>Recursive Lock</h1>

<p>Source module: <code>reclock.cpp</code></p>

<p>Illustrates recursively locking a mutex.  A singleton class,
ResourceManager, can register and unregister clients.  Since this may be
called from the context of any worker thread, it uses a mutex when accessing
the dictionary of client information.  Since retain/release management also
requires the mutex be held during updates, this serves as an illustration of
recursive locking.  These methods can be called individually, or from within
the register/unregister methods, which also hold the mutex.  For example:</p>

<pre><code>registerClient()                  lockCount = 0
    mMutex.lock()                 lockCount = 1
    retainClient()                lockCount = 1
        mMutex.lock()             lockCount = 2
        mMutex.unlock()           lockCount = 1
    mMutex.unlock()               lockCount = 0
</code></pre>

<h1>Deadlock</h1>

<p>Source module: <code>deadlock.cpp</code></p>

<p>Imagine you have multiple co-operating threads as well as multiple shared
resources.  Each shared resource is dutifully protected by its own mutex.
So provided each thread locks the mutex before accessing the resource,
everything should run smoothly, right? What could possibly go wrong?</p>

<p>A <a href="http://en.wikipedia.org/wiki/Deadlock"><strong>deadlock</strong></a> is what could go
wrong, and appears as if the program has simply hung.  It&rsquo;s relatively easy
for these situations to occur, but it is also relatively easy to prevent
deadlocks with some care and thought.</p>

<p>A deadlock occurs when thread one is holding lock A while waiting for lock
B, which itself is held by thread two which is waiting for lock A.  In other
words, the two threads are both waiting for each other to do something that
can never happen.  An <em>impasse</em>!</p>

<p>Now this example is <em>intentionally</em> written to fall into a deadlock.  So
whatever you do, don&rsquo;t copy the code from this example into your own code.
Study it and make sure you understand <em>why</em> it is wrong.</p>

<p>In the source, thread one wants to lock both mutex A and mutex B, and it
does so in that order.  It will then perform some processing, and unlock the
two mutexes.  Thread two is similar, in that it wants to lock mutex A and
mutex B before it can safely do its work.  However, the poor programmer who
wrote this code hadn&rsquo;t had their second cup of coffee that morning, and
wrote the code such that it first locks mutex B, <em>then</em> mutex A.  No big
deal, right?</p>

<p>The program prints information about its progress, including which thread is
in what state, such as processing, waiting for a lock, and so on.  This
makes it easier for us to analyse what is going on.  (When debugging
multithreaded code, <code>printf</code> is your friend!)</p>

<p>Each thread holds both locks while they work, which can take a random length
of time.  This setup can work ok for a little while, provided the timing is
just right.  This can be seen in the trace below, which shows the normal
output of the program:</p>

<pre><code>ONE idle
TWO idle
ONE wait_A
ONE wait_B
ONE processing
TWO wait_B
ONE unlock_B
ONE unlock_A
ONE idle
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
TWO wait_B
TWO wait_A
TWO processing
ONE wait_A
TWO unlock_A
TWO unlock_B
TWO idle
ONE wait_B
ONE processing
ONE unlock_B
ONE unlock_A
ONE idle
TWO wait_B
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
TWO wait_B
TWO wait_A
TWO processing
TWO unlock_A
TWO unlock_B
TWO idle
...
</code></pre>

<p>but before long at all, the program will invariably hang.  At this point,
you will have to use <code>Control-C</code> (or your platform&rsquo;s equivalent) to kill the
program.  And if you run it a few times, you will notice the same two
patterns always appearing at the end of the trace; either:</p>

<pre><code>...
ONE wait_A
TWO wait_B
ONE wait_B
TWO wait_A
</code></pre>

<p>or:</p>

<pre><code>...
TWO wait_B
ONE wait_A
TWO wait_A
ONE wait_B
</code></pre>

<p>Reflecting back to the trace when everything seemed to be working, we see
that the threads ran smoothly when they managed to lock both locks at once.
But notice how these telltale signs, these skidmarks leading up to the
moment of the crash, show thread one and two locking are always
<em>interleaved</em> when they acquire these locks?</p>

<p>In the first example, thread one acquires mutex A, and before it can lock
mutex B, thread two is scheduled, and comes along and locks mutex B. Then
thread one tries to acquire mutex B and blocks since it is already locked by
thread two, waiting forever, being a patient worker thread.  At this point,
thread two can run again, and tries to acquire mutex A.  Unfortunately, this
lock is held by thread one which is not coming back until it gets mutex B &ndash;
which will never happen.  Because thread two is now blocked forever, waiting
on mutex A.  Your only consolation is that they probably won&rsquo;t consume any
CPU cycles while they remain in this deadlock.  But the program certainly
isn&rsquo;t going anywhere!</p>

<p>So how can this be avoided?  Fortunately, the fix is simple &ndash; always acquire
the mutexes in the same order, and (ideally) release them in the reverse
order.  This fix is an exercise left for the reader, but verify for yourself
that the program will run as long as you like once the locks are acquired in
the same order.</p>

<p>Why does this work?  Because it prevents the possibility of holding a
contested mutex while blocking on another.</p>

<p>Remember: <em>Always acquire multiple mutexes in the same order to avoid
deadlocks.</em></p>

<h1>Exclusive Shared Mutex with Access Semantics</h1>

<p>Source module: <code>sharedlock.cpp</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2012/02/threading-with-boost---part-iii-mutexes.html">Threading With Boost - Part III: Mutexes</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2012-02-20T00:00:00+11:00" pubdate data-updated="true">2012-02-20</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In <a href="/2009/05/threading-with-boost---part-i-creating-threads.html">Part I</a> of this series on <a href="http://boost.org/">Boost</a> threading, we looked at the basics of how to create and run threads using the Boost libraries.  Then we reviewed the main issues encountered with multithreading code in <a href="/2010/01/threading-with-boost---part-ii-threading-challenges.html">Part II: Threading Challenges</a>. One of the biggest challenges is safely managing concurrent access to a resource.  A Mutex provides a way to serialise access to a shared resource, such that only one thread is accessing the data at any given time, to ensure your data is consistent.  In this article, we look at how to create and use Boost mutexes.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2012/02/threading-with-boost---part-iii-mutexes.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2011/12/bug-of-the-year-2011.html">Bug of the Year - 2011</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2011-12-24T18:24:00+11:00" pubdate data-updated="true">2011-12-24</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>My favourite bug of all time was uncovered because I was just too impatient.</p>

<p>I was working on a fairly large and complex embedded project.  A microcontroller
was interfacing with some custom hardware. It would configure, control, and
monitor the hardware.  The microprocessor was running an RTOS with a lightweight
TCP/IP stack, so remote clients could connect to the device via Ethernet and
perform remote configuration.  We also used this for diagnostics and testing
during development.  We had successfully used a similar design on several
products, with great results.  We had also designed a protocol for monitoring
and control that was used in earlier models,  and  we extended it here &ndash; though
this product was significantly larger and more complex than its predecessors.
What could possibly go wrong?</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2011/12/bug-of-the-year-2011.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2011/03/good-code-gardening.html">Good Code Gardening</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2011-03-09T12:09:00+11:00" pubdate data-updated="true">2011-03-09</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>During a code review at work recently, we had an interesting discussion about code maintenance.  You could say that coding is a bit like gardening: while you are planting new seedlings, do you weed nearby areas as you go, or save up all the weeding for the next sunny weekend?  Should code maintenance be a continual, gradual process, or does it warrant being scheduled as a task in its own right?</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2011/03/good-code-gardening.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
  
    
      <h1 class="entry-title"><a href="/2010/04/25-tips-for-intermediate-mercurial-users.html">25 Tips for Intermediate Mercurial Users</a></h1>
      
      
    
      <p class="meta">
        








  


<time datetime="2010-04-07T23:58:00+10:00" pubdate data-updated="true">2010-04-07</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I recently read an interesting article by Andy Jeffries entitled <a href="http://andyjeffries.co.uk/articles/25-tips-for-intermediate-git-users">25 Tips for Intermediate Git Users</a> (linked to via <a href="http://www.reddit.com/r/programming/">proggit</a>) .  It had lots of useful information condensed into bite-sized task-oriented chunks.</p>

<p>I&rsquo;ve been using <a href="http://mercurial.selenic.com/">Mercurial</a> for a while now, so I thought I would write a similar set of tips by translating from <code>git</code> to the equivalent <code>hg</code> commands.  Thanks to Andy for blessing this translation work.  There may well be some mistakes herein &ndash; please leave a comment if you have any improvements or fixes to suggest.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2010/04/25-tips-for-intermediate-mercurial-users.html">Read more &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2014/02/c-plus-plus-11-range-based-for-loops.html">C++11 Range-based for loops</a>
      </li>
    
      <li class="post">
        <a href="/2014/02/c-plus-plus-11-futures.html">C++11 Futures</a>
      </li>
    
      <li class="post">
        <a href="/2014/02/c-plus-plus-11-shared-pointer.html">C++11 Smart Pointers: Shared Pointer</a>
      </li>
    
      <li class="post">
        <a href="/2014/01/c-plus-plus-11-unique-pointer.html">C++11 Smart Pointers: Unique Pointer</a>
      </li>
    
      <li class="post">
        <a href="/2013/10/what-is-rust.html">What is Rust?</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Gavin Baker <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a>, customized with <a href="https://github.com/mjhea0/whiterspace">whiterspace</a>.</span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'antonym';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
